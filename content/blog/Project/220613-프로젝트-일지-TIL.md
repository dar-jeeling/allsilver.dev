---
title: '[LUVOOK] 220613-220615 프로젝트 일지 + TIL'
date: 2022-06-13 22:25:25
tags: ['TiL', '프로젝트_일지', 'LUVOOK']
category: 'Project'
draft: false
---

## 프로젝트 일지

이번에는 처음으로 사용하는 라이브러리나 기능도 많았고, 구현할 내용이 꽤 복잡했어서 (PR엔 어렵지 않다고 써놨지만 결과는 미화되니깐요.....) 따로 공부한 내용보다 프로젝트를 개발하면서 배운 점이 더 많았던 주기였다.

### [Swiper 라이브러리](https://swiperjs.com/) 를 이용하여 카드 슬라이더 구현하기

예전에 css 과제를 할 때, 코드 리뷰 하면서 슬라이더를 구현하신 팀원 분이 계셨는데 개발할 때 엄청나게 고생하셨던 것을 보았고, 개발한 결과물을 리뷰 할 때도, 동작을 잘 파악하기가 힘들었기 때문에, [`Swiper`](https://swiperjs.com/) 라는 라이브러리를 사용하기로 결정하였다. 나름 대중적인 라이브러리 라고도 하고, 사용법도 쉽다고 해서 쉬운줄 알았는데...그것도 결과가 미화된게 아닐까?

- Swiper 는 기본적으로 css 선택자에 스타일을 씌우는 방식으로 적용이 되기 때문에, 세부적인 스타일을 적용하기 위해서는 해당 요소의 선택자에 css 속성을 덧씌우는 방식을 사용하여야 했다.
- 라이브러리 속성을 하나하나 공부할 시간은 없었으므로... github에서 멋진 개발자 선배분들이 swiper 로 작성하신 코드 염탐과 개발자도구의 요소 검사를 이용하여 이리저리 바꿔가면서 최우선으로 필요한 부분만 구현하였다. **따라서 지금 작성하는 내용도 경험에 의한 것이라서 잘못된 정보일 확률이 높다.**

  \- swiper 를 이용하여, 여러 개의 slide를 보이도록 할 때, 기본적으로 이 slide가 앞쪽으로 정렬되어 있는데, 이 silde 들을 중간으로 배치하게 하기 위해서는 React 가준으로 SwiperSlide 에 인라인으로 스타일을 넣어준다. (물론 이는 클래스 선택자를 이용하여 `swiper-slide` 클래스에 따로 스타일 속성을 넣어주어도 된다.)

  \- 처음에는 `centeredSlides` 와 같은 속성을 사용하는 줄 알았는데... 이 속성의 경우, **활성화된 슬라이드 를 가운데에 비치시키는 것** 이므로.. 여러 개 슬라이드를 가운데 비치시키는 속성과는 거리가 있는 느낌이였다.

  \- width를 계산해서 양끝에 offset을 주는 방식(`slidesOffsetAfter`, `slidesOffsetBefore` 속성을 이용)도 생각해보았으나, 이 offset이..... 한 번에 보이는 슬라이드의 양 끝이 아니라 진짜 처음 슬라이드의 왼쪽과 마지막 슬라이드의 오른쪽을 의미하는 것이였다ㅠㅠ

  \-  한 번에 넘어가는 갯수는 `sildesPerView` 를 통하여 정의한다. (처음에 하나씩 넘어가서 답답했다...) 이는 한 줄 기준으로 작성해주면 된다.

- 현재 swiper의 최신버전에서는 `grid` 라는 속성을 지원하는데 이 속성을 사용하여 여러 줄의 슬라이드를 한번에 보여줄 수 있다. (multi-rows) 이 때, 줄(row)방향으로 여러 줄을 쌓기 위해서는 다음과 같은 속성을 넣어주어야 한다.

```javascript
 grid={{ fill: 'row', rows: 2 }} // row 방향으로, 2줄로 채워나간다.
```

- `grid` 속성을 사용하게 되면, 역시 css 클래스로 슬라이드 뷰를 감싼 wraper 가 만들어지는데, 이는 .swiper-grid 라는 클래스 이름을 갖는다. 따라서, grid 속성에서 row 간격을 제어한다던가 하려면 `.swiper-grid > .swiper-wrapper` 를 통하여 제어를 한다.
- 기본적으로 `grid` 는 `flex`로 구현되어 있으며, `flex-wrap` 속성을 이용하여, 화면에 꽉차면 줄이 생기면서 내려가는 방식을 사용한다. **따라서, 여러 줄을 제어하기 위해서는 `align-content`를 사용한다.** (배운 내용이였는데 까먹어서 `align-items` 와 `justify-content` 로 구현하려고 애쓰다가 엄청나게 고생했다...)

### propTypes 에 객체 내용까지 설정하는 방법

```javascript
import PropTypes from 'prop-types'

propTypes: {
  data: PropTypes.shape({
    id: PropTypes.number.isRequired,
    title: PropTypes.string,
  })
}
```

- `PropTypes.shape`를 이용하여, 안쪽에는 객체의 key를 key 로 하고, 그 key 에 해당하는 value 가 가져가야할 타입을 value로 작성한다.

### Objects are not valid as a React child (found: object with keys {키1, 키2}). If you meant to render a collection of children, use an array instead.

이건 사실 React  에서만 만난 오류는 아니고 밥 먹듯이 자주 만나는 오류였는데, 매번 찾아보고 있어서 이 김에 정리해둔다...

- `.map`, `.filter`, `.reduce` 와 같은 고차함수는 배열이나, 유사배열에만 사용할 수 있다. 따라서, object 에 고차함수를 사용하기 위해서는 `Array.from` 메서드를 활용하거나, `...(스프레드 연산자)`를 사용하여 배열로 만들어주고 사용한다.

### 리액트에서 list의 key를 index로 사용하면 안되는 이유

코드 리뷰를 하면서, 나도 다시 한 번 조심해야할 부분이라고 느꼈다.

- React의 경우, list를 렌더링 할 때 각 list에 주어진 key를 이용하여 최적화를 한다. (예를 들어 key에 따라서 다시 렌더링 할 li를 정한다던가...) 따라서 index와 같은 unique 하지 않은 값을 사용한다면 side-effect 가 발생할 수 있다.

### 깔끔하게 axios 에서 응답 data 사용하기 ( feat. 클린코드의 신, 우리 팀장님)

- axios 를 사용하여 요청을 한 다음에는 응답 객체가 내려오는데, 이 때 응답 데이터는 응답 객체의 data 프로퍼티를 통하여 사용할 수 있다. 즉, api 요청을 하는 곳에서 구조 분해 할당을 이용하여 data를 꺼내오는 형태로, 코드를 더 깔끔하게 사용할 수 있다.

```javascript
const { data } = await axios.get(`/어쩌고`)~~~
```

### async/await와 .then 을 함께 사용하는 것은 안티패턴이다. ( feat. "그 분)

- 예전에 Vanilla JS 강의를 들을 때도, 강사님이 언뜻 `async/await`와 `then`을 섞어 사용하는 코드에 대해서 부정적인 뉘앙스를 취하셨었는데... 완전히 잊고 있었다가, 갑자기 등장하신 "그 분" 덕에 `await` 와 `async/await`를 함께 사용하는 것은 안티패턴 이라는 것을 상기할 수 있었다.
- [stackOverFlow](http://using%20async await and .then together) 나 [stack Exchange](https://softwareengineering.stackexchange.com/questions/378471/is-it-conventional-to-use-both-await-and-then) 에서도 `async/await` 와 `.then` 을 함께 사용하는 경우 예기치 못한 결과를 만들어 낼 수 있으니 사용을 피하라고 권고한다.
- `async/await`에 대한 [MDN DOCS](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function) 의 설명을 보면

> An async function can contain an await expression that pauses the execution of the async function and waits for the passed Promise's resolution, and then resumes the async function's execution and returns the resolved value.
>
> async 함수는 await 표현식을 포함하는데, 이는 async 함수의 실행 중 일시 정지(pause) 하고, Promise resolution을  전달 받을 때 까지 기다립니다. 그리고 async 함수의 표현식을 실행하고 나서 resolced 된 값을 리턴합니다.

즉, `async/await` 는 '잠시 기다리기' 때문에, `.then` 을 사용하면 `async` 함수의 리턴값이 나오기 전에 `then`으로 처리되어 예상치 못한 결과를 낳을 수 있다는 말이다.

## TIL

✨ = 내 생각 비중이 높음

✨ 프로젝트에서 컴포넌트를 구현할 때 컴포넌트에 재사용성에 대한 피드백을 상당히 많이 받아서, 관련 자료를 찾아보는 중이다.

### [컴포넌트, 다시 생각하기](https://www.youtube.com/watch?v=HYgKBvLr49c&t=82s)

- React 컴포넌트가 가지는 의존성은 **스타일, 로직, 전역 상태, 리모트 데이터 스키마** 로 분류해볼 수 있다. 이 중 **리모트 데이터 스키마는 원격에서 내려주는 데이터를 의미** 한다.
- React 컴포넌트를 재사용할 때, 새로운 정보를 추가하기 위해서 새로운 props를 정의하게 될텐데, 이 때 컴포넌트는 **새로운 정보 뿐만 아니라 다른 수정사항도 필요** 하다. 이러한 다른 수정사항들을 **숨은 의존성** 이라고 한다.
- 특히나, 리모트 데이터 스키마의 경우, 내려받는 데이터의 형태가 바뀌는 경우, 그 정보 뿐만이 아니라 데이터를 사용하는 부분의 상당 수를 수정하게 된다.(✨ 실시간으로 겪고 있는 내용이다....) 이러한 컴포넌트 의존성을 피하는 방법을 생각해보자.

#### 1\. 함께 두기 (Co-locate)

- 어떤 부분을 수정해야할 때, 파일이 서로 멀어지게 되면 집중력이 분산된다. 따라서 비슷한 관심사를 가진 파일이라면 같은 파일 안에 두거나 바로 옆에 두는 것이 좋다.

  ✨ 코드 리뷰 받은 부분에서, css 파일을 분리했을 때 css 파일을 분리하는 점이 컴포넌트의 응집도를 떨어뜨린다. 는 리뷰를 받은 적이 있었고, 따라서 CSS-In-JS의 목적에 대해서 생각해볼 기회가 있었다. 이 컨퍼런스 영상에서도 로직과 스타일을 "함께 두는" 방법으로 CSS-in-JS를 제시하였다.

  ✨ 또한, "그 분"이 storybook 파일을 따로 stories 디렉터리 안에 두는 것에 대해서 의문을 제기하셨는데 이 또한 어떻게보면 "함께 두기"에 위반되는 점이라고 할 수 있다. 확실히, storybook 안에서는 .stories.js로 만들어두면 함께 보이니깐 같은 디렉터리 안에서 컴포넌트를 만들고 테스트하는 용도로 story 파일을 사용하면 편할 것 같다는 생각이 들었다. (실제로도 stories 디렉터리와 컴포넌트 디렉터리가 멀리 떨어져있어서 불편하기도 했고...)

- 리모트 데이터 스키마를 사용할 때, 루트 컴포넌트에서 다른 컴포넌트들을 타고 내려오는 형태로 많이 사용한다. (✨ 당장 작은 컴포넌트에 api를 붙이는 건 컴포넌트의 "순수함"을 떨어뜨리는 행위이므로, 루트 컴포넌트에서 리모트 데이터 스키마를 처리하게 된다)

  이 때, 리모트 데이터 스키마의 "형태"에 따라서 하위 컴포넌트의 의존성이 생기게 되는데 (✨ 리모트 데이터 스키마를 활용하는 경우, 이 스키마에 맞게 컴포넌트를 뿌려주게 된다) props 에 해당 데이터가 아닌 id를 받게 하여 끊어내도록 한다.

#### 2\. 데이터를 ID 기반으로 정리하기 (Abstraction by Normalization)

✨ 이 내용은 개발 경험이 부족해서인지 잘 와닿지가 않아서ㅠㅠㅠ... 결국엔 컴포넌트 모양이 리모트 데이터 스키마의 모양에 의존하게 되면 숨은 의존성이 생기므로 내려주는 방식이 아니라 루트 컴포넌트에서는 id만 내려주고, 루트 컴포넌트에서 fetch 한 데이터는 저장소에 넣어두고, 그 저장소를 이용하라는 것 같은데... 나는 이 내용이 내가 알고 있는 전역 상태에 관련한 내용과 충돌을 일으켜서 잘 이해가 되지 않았다ㅠㅠ.. 이는 조금 더 경험해보고 이해해봐야할 것 같다.

#### 3\. 의존한다면 그대로 드러내기

- props (다른 변수 같은 부분도 마찬가지일 듯) 의 이름을 지을 때, 컴포넌트에 존재하는 의존성들을 이름에서부터 명확하게 드러내도록 하자.
- 이는 의존하고 있는 "모델"과의 관계성을 위주로 이름을 짓는다.

#### 4\. 모델 기준으로 컴포넌트 분리하기

- 컴포넌트를 만들 때, **기존에 있던 컴포넌트를 재사용할지, 복사해서 새 컴포넌트로 분리될지 에 대해서 고민이 된다면,  모델 기준으로 컴포넌트를 분리한다.**
- 우리가 개발하는 제품은 **끊임없이 변화하면서도 유저에게 일관된 경험을 제공해야한다**. 이러한 일관된 경험은 **대부분 모델을 기반으로 하기 때문에, 변화의 방향성 역시 모델 기준으로 변화** 하게 된다.

✨ 예전에 팀원 분이 LoginForm과 SignUpForm 에 대해서, 코드가 반복되는 것 같아서 재사용할 부분이 있을 것 같다고 말씀하셨고, 그 때 나는 Form 자체를 만들고, props로 각 기능을 제어하는게 어떻겠냐는 말을 해드린적이 있는데.. 아무래도 말을 잘못한거 같다ㅋㅋㅋ 왜냐하면 LoginForm 과 SignUpForm은 현재의 구현 단계에서는 비슷하게 생겼지만, 이 둘은 다른 기능을 하는데다가, 또 다른 api에 의존하고 있으므로 미래에는 다른 방향으로 변화하게 될 컴포넌트가 될 것이다.

✨ 따라서, 컴포넌트를 너무 추상적으로 쪼개놓는 것에 대해서 경계를 해야겠다는 생각이 들었다. 특히나 예전에 atomic design에 대해서 잠깐 알아보면서, atomic design의 경우 컴포넌트가 파편화되면서, 결국 이 컴포넌트들이 어떤 기능을 하는지 명확하게 구분하기 어려워지며, 컴포넌트 간의 의존성과 복잡도가 까다로워진다는 점이 문제점이라는 내용을 읽었었다. atomic design의 경우, 결국 재사용성 에 초점을 맞춘 디자인 패턴이라고 (내가) 생각하는데, 기존에 있던 컴포넌트의 재사용에 초점을 맞춘 나머지, 변화의 방향에는 초점을 맞추지 못하여 문제점들이 발생하는 것 같다. (무조건적인 재사용의 사이드 이팩트...? 같은 생각이다)

## Reference

> [[A3] 컴포넌트, 다시 생각하기 | 유튜브, FEConfKorea](https://www.youtube.com/watch?v=HYgKBvLr49c&t=82s)
