---
title: "[아트zip] 프로젝트 일지, TIL"
date: 2022-07-23 02:46:41
tags: ["Artzip", "프로젝트일지"]
draft: false
---
## 프로젝트 일지

## 문서화

- 1:1 커피챗을 하면서 문서화를 할 때, 한 곳에 몰아넣는 것에 대하여 조언을 얻었다.

    예를 들어서, 한 레포에 어떠한 커스텀 훅이 정의되어있다면 해당 커스텀 훅을 md 파일로 정리한다던가, 브랜치 전략에 대한 내용을 md 파일에 정리하는 방식이다.
- 노션에는 다양한 필터 기능이 존재하니 적당히 사용할 수 있어야 한다. 예를 들어서, 캘린더 view의 경우 프로젝트가 끝나면 캘린더가 넘어간다던가 할 수가 있는데, 나중을 대비하여 list view로 바꾸거나, 문서의 내용을 제목에 드러내던가 하면서 **항상 어딘가에 보여진다는 생각** 을 하면서 문서화를 해야한다.

### 사용자 경험 측면에서의 Modal 사용

- 모달이라는 부분 자체가 UX 면으로 좋은 아웃풋은 아니라고 한다. 따라서 모달은 최소화하는 방향으로 개발해야 한다. ✨ 생각해보면 나도 노션에서 글 수정할 때 모달 뜨면 바로 전체화면으로 바꿔버리긴 한다...ㅋㅋㅋ
- ✨ 멘토님이 모달에 대한 조언을 해주시면서, 모달은 데이터 분석할 때나 사용자가 어떤 기능을 사용했는지 체크가 불가능하기 때문에 불편하다고 하셨다. 즉, 모달은 개발자 입장에서 상태를 관찰하기 어렵다는 단점을 가진다는 말 같다. 그야 당연히, 모달은 한 페이지 내에서 보여주는 형태를 사용하는데 결국 그 상태가 한 페이지에 존재하게 되면서 개발자 입장에서 체크가 어려워진다.
- ✨ 실제로 이전 프로젝트(LUVOOK)에서 모달 맡으신 분들이 상당히 고생하는 것을 보았고, 1기 분도 모달에 대한 설명을 하셨는데, UI의 일부분에 Context 를 작게 사용해서 모달의 상태를 관리하시기도 하였다. 지금 생각해보면, 이런 기법은 Next.js 의 본질적인 props drilling 을 방지하기 위해서 사용할 수도 있을 것 같다는 생각이 든다. 물론 Next는 page 단위로 props drilling이 일어나므로, 모달 처럼 아예 작은 단위는 아니라서 context 를 사용하면 context 특유의 리렌더링 문제를 겪을 수도 있다는 생각이 든다. (그래서 recoil과 같은 상태관리 라이브러리를 쓰는걸까?)

### 전역 상태 관리에 대한 단상

- React 공식문서의 Context 관련 내용에서도 전역 상태 관리는 정말정말 필요한 곳에서만 사용하라고 하고, 멘토님의 조언 역시 전역 상태 관리의 목적은 굉장히 뚜렷하고, 실제로 앱내부에서 전역 상태 관리로 필요한 부분이 거의 없다고 한다. 오히려 전역 상태 관리의 경우, 프론트 내에서 컴포넌트 설계 등에 있어서의 관리 포인트라고 하셨는데....
- ✨ 위에서 말했던 Next 의 경우,getServersideProps 와 같은 api는 page 단위에서만 사용하므로 불가피한 props drlling이 발생할 수 밖에 없다ㅠㅠ....... 이런 부분을 전역 상태관리로 나눠서 관리할 수 있지 않을까? 라는 생각을 해보지만.............. 상태관리가 복잡해진다는 느낌이 든다.
- ✨ 그럼에도 불구하고 전역 상태 관리 라이브러리가 쏟아져 나오고, 어떤 단점을 계속 보완하는 이유는 뭘까? 라는 의문이 들었다. 조금 더 경험해보고 커다란 애플리케이션을 만들어봐야 와 닿을 것 같다ㅠㅠ

## 무한 스크롤, useInfiniteScroll

- ✨ 우선은 프로젝트가 급하므로, (권장하는 방식은 아닌 것 같지만) scroll 이벤트를 이용하여 무한 스크롤을 구현하였다. (스크롤 끝이면 데이터 fetching을  또한 scroll 이벤트의 특성 상 상당한 오버헤드가 발생하므로, 얼마전 딥다이브 스터디에서 공부한 throttle을 이용하여 이를 최적화 하였다.
- ✨ throttle을 통하여 일정 시간 마다 이벤트가 호출되도록 할 수 있다. setTimeout 을 자주 사용한다고 생각할 수 있으나, setTimeout을 사용하게 된다면 throttle의 정의인 "일정시간마다 특정 콜백 함수가 실행하는 것을 보장한다" 라는 점을 지킬 수 없게 된다. (왜냐하면 setTimeout의 경우 macro task queue에 저장되어 관리되는데, 이벤트 루프는 macro task queue에 있는 컨텍스트를 call stack 이 비어있을 때, call stack에 push 하게 되므로 delay 가 생길 수 있고, 이 시점이 설정해 준 delay와 맞지 않으면 등록해둔 call back 함수가 trigger 되지 않을 수 있다)
- ✨ 따라서, 일정시간마다 콜백 함수가 실행되는 것을 보장하기 위하여 requestAnimationFrame을 이용한다. 이 rAF는 브라우저가 렌더링할 수 있는 '능력'애 맞춰서 animation frame에서 처리된다.
- ✨ 여전히 커스텀 훅을 만드는 과정이 까다롭다고 느꼈다. 커스텀 훅은 "상태state를 가지는 함수"라고 생각하면 된다고 한다.. 이번에 만든 useInfiniteScroll의 경우, 스크롤이 스크롤 맨 끝까지 닿았는지의 상태를 판단하여, 컴포넌트에게는 이 상태에 따라서 "데이터를 fetching해야하는지"의 상태를 넘겨주게 된다.

## MSW를 사용하여 data mocking 하기

- ✨ 중간 프로젝트 중 어려웠다고 많이 꼽히는 부분이 비동기 로직 처리 부분이였다. 특히나 api 가 준비되는 시점과 (왜냐하면 잘못 요청하면 서버가 터졌기 때문) api 를 붙이는 시점이 달라서 api 를 붙이는 작업 자체가 꽤나 까다로운 작업이였으며, 이 부분에서 버그도 많이 발생하였다.
- ✨ 임시팀때부터 스터디를 함께 해주신 감사한 분이 MSW를 알려주셔서, api 개발 시점과 UI 로직의 개발 시점의 시차를 줄이기 위하여 MSW를 활용해보기로 하였다. 특히나 MSW를 사용하는 것은 nextJS와 궁합이 잘 맞다고 생각하였다. 왜냐하면 nextJS를 처음 사용해보는 입장에서 getServerSideProps나 getStaticProps를 사용하는게 상당히 어색했는데 msw 를 통해 가짜 api를 사용함으로써, 실제 back과의 통신과 비슷한 환경에서 UI 로직을 개발할 수 있다는 점이 굉장히 좋다고 느껴졌다. (또한 mock데이터를 통해 back 에서 만들어준 api 명세를 다시 한 번 확인하고, 맞춰나갈 수 있는 계기가 되었다)

## T(his week)IL

### Effective Typescript

- 코드 생성과 타입은 관계가 없다. 타입스크립트는 크게 1\. 타입스크립트를 자바스크립트로 트랜스파일하는 역할을 하고, 2. 코드의 타입 오류를 체크한다. 따라서 이 두 가지 작업은 독립적으로 일어나게 되고, 트랜스파일이 될 때 타입에 관한 정보는 사라지게 된다.

    ✨ 타입 스크립트에서 어떤 타입을 판단할 때, in 연산자를 사용하는 기법을 많이 사용하는데, instance of 와 같은 연산자로 타입에 속하는가를 판단하게 되면, 타입 정보에 관한 내용은 트랜스파일되면서 사라지므로 없는 연산이 되어버린다...

    ✨ 대안으로 tagged union과 같은 기법 역시 많이 사용한다.
- ✨ 즉, 타입 스크립트의 동작을 이해할 때, 타입 (런타임 접근 불가) 와 값 (런타임 접근 가능)의 동작을 이해해둬야 한다.
- 어쨌든 타입 스크립트는 자바스크립트의 동작을 모델링한 언어이므로, 타입을 판단하기 위하여 자바스크립트의 덕 타이핑을 모델링하게 되었는데, 이 말은 타입이 완전히 '봉인'되어있지 않다는 말이다.
- ✨ 즉, 구조적으로 필요한 속성이 존재하면 오류를 체크하지 않는다. 따라서 선언한 타입에서 key 를 순회할 때, 특히나 주의해야한다.(key를 순회할 때, 타입에서 정확하게 선언한 타입을 사용해야 한다.)

### 토스ㅣSLASH 21 - 실무에서 바로 쓰는 Frontend Clean Code

- ✨ 영상을 본 지 조금 오래되서 (죄송합니다).... 우산 가장 와닿는 내용은 남이 내 코드를 볼 때, 원하는 로직을 빠르게 찾기 위해서 중요한 것은 코드의 추상화 수준을 비슷하게 가져가라는 내용이였다.
- ✨ 즉 페이지 컴포넌트를 구현한다고 할 때, 페이지를 구성하는 컴포넌트들의 추상화(세부 구현 단계) 수준이 뒤죽박죽 섞여있으면 (어떤건 마크업 구조가 그대로 드러나있고, 어떤건 모든 값을 props로 받는 컴포넌트로 되어있고) 코드를 이해하기 힘들다는 의미이다.
- ✨ 컴포넌트의 추상화를 생각하면서 atomic design pattern이 생각났다. 이 패턴에서 atom-molecule-organism-template-page 순서대로 컴포넌트가 구체화되는 면이 있는데 (예전에 모 강사님의 아티클에서 molecule과 organism의 구분 기준이 사용자에게 구체적인 기능을 제공하는가를 생각해보라는 내용이 떠올랐다) 한 페이지에서 atom에 속하는 컴포넌트, molecule에 속하는 컴포넌트, organism에 속하는 컴포넌트가 섞여 있다면 이 들의 추상화 수준이 다르므로 페이지가 다소 난잡해질 수 있다.

    ✨ atomic design pattern의 문제점이라고 꼽히는 "컴포넌트가 파편화 된다"가 이 이야기 인 것 같다. 원자에 해당하는 컴포넌트의 수가 너무 늘어나게 되면 추상화 수준이 너무 높은 컴포넌트만 남아버리고, 그리고 추상화 수준이 너무 높다면 어떤 기능을 하는지 파악하기가 어려워 진다.
- ✨ 또한 함수의 '단일 책임' 역시 중요한 포인트로 말씀해주셨는데, 이는 얼마전에 읽다(만) 아티클인 React에 SOLID 원칙 적용하기 를 다시 읽으면서 정리하기로...

### Next JS

- ✨ Next JS를 사용하는데 망설였던 점 중하나가 SSR의 컨셉이 와닿지 않았다.

    왜냐하면 SSR이라고 하면 서버에서 페이지 마다의 html을 내려주게 될 건데, 그렇다면 이 html을 네트워크에서 보내는 시간이 분명 존재할 것이고 이 시간이 CSR에서 js가 화면을 그리는 시간보다 빠르다는 것을 어떻게 보장하는가?
- ✨ 여기서 내가 간과했던 점은 NextJS의 SSR은 전통적인 SSR과는 다른 면이 있다는 것이다. NextJS는 빠른 렌더링을 위하여 SSR과 CSR이 혼합된 형태를 사용한다. 이 과정을 hydration이라고 하는데, 이는 먼저 렌더링을 느려지게 하는 동적인 요소를 제외한 부분으로 먼저 페이지를 내려주고, 그  이후에 (수분을 채워넣듯이) CSR 과 같은 방식을 통하여 화면이 동적으로 움직일 수 있게 만들어 준다.

## Reference

더보기

[https://jbee.io/web/optimize-scroll-event/](https://jbee.io/web/optimize-scroll-event/)

[스크롤 이벤트 최적화\
\
\
⚠ 이 포스팅은 자바스크립트의 비동기 처리에 대한 이해를 기반으로 작성되었습니다. 이 포스팅을 읽기 전, JavaScript의 Event Loop와 자바스크립트 비동기 처리 과정 일독을 추천 드립니다. 우리는\
\
\
jbee.io](https://jbee.io/web/optimize-scroll-event/)

[https://www.youtube.com/watch?v=edWbHp\_k\_9Y&list=PLOqV3DRrzSj03UEpsNdRJiZLAMld2BjO4&index=15](https://www.youtube.com/watch?v=edWbHp_k_9Y&list=PLOqV3DRrzSj03UEpsNdRJiZLAMld2BjO4&index=15)