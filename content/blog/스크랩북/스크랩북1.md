---
title: '스크랩북 1'
date: 2022-11-18 17:17:46
tags: ['Recoil', 'Next.js', 'CSS-in-JS']
category: '스크랩북'
draft: false
---

🌧 = 나의 주관적인 생각

## Article

### 모든 죽음에는 애도의 방법이 따로 있다.

> [[기자수첩] 모든 죽음에는 애도의 방법이 따로 있다](https://www.boannews.com/media/view.asp?idx=109939)

- 유명한 사람의 죽음에서 시작하여, 사고에 의한 죽음을 설명하고 이러한 죽음의 종류에 따른 사후 처리(이 글에서는 애도라고 표현)에 방식을 설명한 후, "보안" 관점에서의 "죽음"과 애도의 방식을 이야기하는 글이다.
- 🌧 글 자체는 9월에 쓰여진 글이지만, 11월 3주차에 바라봐도 굉장한 시의성을 지닌 글이다. 당장 이 글이 쓰이고 난 이후에도 여러 가지 죽음을 함께하였다. 얼마 전 있었던 이태원 참사 사건은 (글에 표현에 따르면) 직접적으로 남은 삶에 영향을 주고, 역사의 방향을 전환시키는 계기가 되었다.
- 🌧 글을 읽자마자 가장 먼저 생각난 "죽음"은 카카오 데이터센터 화재 사건이었다. 이 글에서는 "보안" 관점에서 이야기를 하지만, "데이터", 더 나아가서 "컴퓨터 엔지니어링"에서도 마찬가지이다. 애도는 커녕 손가락질을 하는 죽음. 당장 그 사건이 일어나고 카카오와 관련된 모든 서비스가 마비되었을 때, 돌아오는 대부분의 반응들이 "왜 미리 대비를 하지 않았는가"에 대한 손가락질 이였다. 특히나 전문적인 분야로 갈 수록 "죽음"은 숨겨진 선물을 찾아내는 과정이 아니라 회초리로 사용되고 있었던 것이다.
- 🌧 "컴퓨터 엔지니어링" 관점에서의 "죽음"은 압도적으로 공격자들이 유리한 위치에 있다. 지금까지 나의 프로그래밍에 있어서의 "죽음"을 생각해 본다. 그리고 앞으로도 발생할 나의 프로그래밍의 "죽음"을 생각해 본다. 내가 이 "죽음"을 나 스스로를 매질하는 회초리로 사용할 것이 아닌 "숨겨진 선물"로 사용하는 방향으로 관점을 옮길 필요가 있다.

### [번역] 우리가 Next.js로 리액트 로딩 시간을 70% 개선한 방법

> [[번역] 우리가 Next.js로 리액트 로딩 시간을 70% 개선한 방법](https://velog.io/@cookie004/improved-react-loading-times-with-nextjs)
>
> [원문 : How We Improved React Loading Times by 70% with Next.js](https://www.causal.app/blog/next-js)

- CRA 에서 Next.js 로 마이그레이션 했을 때, 얻은 관점을 초기 페이지 로드 시간과 개발자 경험의 관점에서 작성한 글이다.
- 🌧 내가 Next.js 를 처음으로 도입했을 때, 얻을 수 있었던 이점들과 어느정도 일맥상통하는 내용이 있었어서, 공감하면서 읽을 수 있었던 글이었다. 특히나 Next.js 가 "프레임워크"로써의 장점을 잘 살리고 있기 때문에, 협업에 있어서의 개발자 경험에 있어서 유리하다는 점이 상기되었다.
- 🌧 다만, 우리 프로젝트에서는 (React 만 사용하는 것과 비교하지는 못했지만) 첫 페이지 로딩 속도에 대한 이점을 크게 느끼지 못하였다. 글에서는 호스팅 방법에 따라서 서버 사이드 렌더링을 위한 필요한 네트워크 거리를 세밀하게 제어할 수 있다고 한다.
- 🌧 내가 처음에 SSR 방식에 대해서 이점에 잘 공감하지 못했던 것이 이 이유였다. CSR 방식으로 자바스크립트가 화면을 그리는 시간과 SSR 방식으로 서버와 통신하는 과정(지연 시간)의 시간 차이가 나에게는 현실적으로 느껴지지는 않았었다. (이러한 부분은 next.js 공식문서의 hydrate 를 읽으면서 해소하였다.)
- 🌧 어쨌던간에 배포 시, 커스텀 도커 이미지를 사용하면 더 빠른 서버 사이드 렌더링을 위한 세부 설정을 할 수 있다는 점이 아주 흥미로웠다.

### (번역) 엣지(Edge) 컴퓨팅이 뭘까요? 강아지 모자를 뜨개질하는 것과 같습니다.

> [(번역) 엣지(Edge) 컴퓨팅이 뭘까요? 강아지 모자를 뜨개질하는 것과 같습니다.](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EC%97%A3%EC%A7%80-edge-%EC%BB%B4%ED%93%A8%ED%8C%85%EC%9D%B4-%EB%AD%98%EA%B9%8C%EC%9A%94-%EA%B0%95%EC%95%84%EC%A7%80-%EB%AA%A8%EC%9E%90%EB%A5%BC-%EB%9C%A8%EA%B0%9C%EC%A7%88%ED%95%98%EB%8A%94-%EA%B2%83%EA%B3%BC-%EA%B0%99%EC%8A%B5%EB%8B%88%EB%8B%A4-e97748d88b0c)
>
> [원문 What is Edge Compute? It’s kind of like knitting dog hats](https://austingil.com/edge-compute-knitted-dog-hats/)

- Edge computing 을 강아지 모자 뜨는 것에 비유해서 설명한 글이다. 글에서는 우선 "컴퓨팅"을 정의하고, 이를 "강아지 모자를 뜨는 일"에 비유하고 각각의 렌더링 방식들을 "강아지 모자 뜨는 방식"에 비유하여 설명한다.
- 🌧 공학 작문 시간에 좋은 글을 읽고, 좋은 글을 소개하라는 과제를 받았을 때 좋은 글의 예시로 내가 뽑았던 글 이었다. 이후에 교수님의 추천 글로 뽑히기도 하였는데 말씀하시면서 기술 설명을 쉽게 하고자 하면 참고하면 좋지만, 이런 식으로 글을 쓰려면 상당한 내공과 해당 기술에 대한 완벽한 이해가 필요하기 때문에 아직은 가급적이면 이런 식으로는 글을 쓰지는 말라고 하셨다....
- 🌧 "가장 가까운 서버에서 가져오도록 한다"라는 Edge Computing 의 컨셉을 이해해 볼 수 있었고, 왜 Next.js 에서 그렇게 SSG 를 강조하면서 CDN 을 이용하므로 가급적이면 SSG 를 사용하기를 권한다. 라는 이야기를 했는지 깨달을 수 있었다. (글에서도 CDN은 위의 SSG와 같은 것들과 훌륭한 짝을 이룬다. 고 언급되어 있었다.)

### (번역) 우리가 CSS-in-JS와 헤어지는 이유

> [(번역) 우리가 CSS-in-JS와 헤어지는 이유](https://junghan92.medium.com/%EB%B2%88%EC%97%AD-%EC%9A%B0%EB%A6%AC%EA%B0%80-css-in-js%EC%99%80-%ED%97%A4%EC%96%B4%EC%A7%80%EB%8A%94-%EC%9D%B4%EC%9C%A0-a2e726d6ace6)
>
> [원문 : Why We're Breaking Up with CSS-in-JS](https://dev.to/srmagura/why-were-breaking-up-wiht-css-in-js-4g9b)

- CSS-in-JS (런타임 CSS-in-JS) 발생시킨 성능 문제와 이를 해결하기 위하여, Sass 모듈을 도입한 이야기를 담은 아티클이다.
- 아티클에서 말하는 CSS-in-JS 의 단점
  - Emotion 이나 styled-components 의 경우, 런타임 CSS-in-JS 로 앱이 실행될 때 라이브러리가 스타일을 해석하고 적용한다. 따라서 컴포넌트가 렌더링 될 때, 라이브러리가 스타일을 해석하고 적용하기 위하여, 라이브러리를 다운로드하고 불러오는 + 런타임 CSS-in-JS를 document 에 불러올 수 있는 일반 CSS 로 스타일을 직렬화 하는 런타임 오버헤드가 더해진다.
    - 🌧 이렇게 스타일을 직렬화 하는 도중에 일반 CSS 의 해시를 계산한다. 이 해시는 생성된 클래스 이름에서 확인할 수 있는데, 개인적으로 개발자 도구의 요소 검사 등을 이용할 때, 클래스의 이름이 무엇을 가르치는지 파악하기가 힘들어서 디버깅이 불편했던 경험이 있다. (클래스를 통하여 더욱 코드를 보기 쉽게 만들어주는 BEM 과 같은 기법도 사용할 수 없고...)
  - 마찬가지로 CSS 규칙의 하여 브라우저에서 더 많은 추가 작업을 수행하게 된다. React 에서는 새로운 스타일 규칙을 삽입할 때마다 해당 규칙이 기존 트리에 적용되어 있는지 재계산 하는 절차를 거치는데, 앞에서 말했다싶이 런타임 CSS-in-JS 라이브러리는 컴포넌트가 렌더링 될 때 새로운 스타일 규칙을 삽입하면서 작동하게 되기 때문에, 계산량이 늘어난다.
  - 또한 (Emotion 의 경우) css 프로퍼티를 사용하는 각 요소에 대하여 `<EmotionCssPropsInternal>` 및 `<Insertion>` 과 같은 컴포넌트를 렌더링 한다. 따라서 React DevTools 를 어지럽힌다.
  - SSR 이나 컴포넌트 라이드러리를 사용할 때 잘못될 수 있는 부분이 많다.
    - 🌧 실제로, Art.zip 프로젝트를 할 당시에도 (내 쪽의 이슈는 아니였어서 정확하게 기억나는 건 아니지만) Antd 에서 제공하는 Card 컴포넌트를 styled 로 감싸서 새롭게 스타일링을 하려고 할 때, 팀원 분이 상당히 애를 먹으셨다는 말씀을 하셨다.
- 🌧 코드의 대부분의 예시는 css 를 사용하고 있었다. 그동안 emotion 을 사용하면서 styled 를 주로 사용해왔는데, css 를 쓰시는 분들 입장을 조금 검색해보니 css 를 사용하는 쪽이 보기 편하고, 타입 체크 등의 장점이 있어서 사용하신다고 하셨다. 다음에 emotion 을 이용할 때, css 프로퍼티를 사용해보도록 해야겠다.
- 이 글의 필자는 CSS-in-JS 의 이점을 최대한 유지하기 위하여, Sass 모듈을 도입하면서 요소에 단일 프로퍼티를 설정하는 유틸리티 클래스를 도입하였다.
- 🌧 여러모로 CSS-in-JS 에 단점이 있긴 하지만, 분명히 장점도 있기 때문에 (특히나 자바스크립트 변수나 컴포넌트의 프로퍼티와 스타일을 일치시켜서 사용할 수 있다는 점이 강력하다고 생각하다) 프로젝트의 성격에 맞게 "잘 선택" 하는 것이 중요하다는 생각이 들었다.

## Conference

### [B1] 상태관리, 이제 Recoil 하세요.

> [[B1] 상태관리, 이제 Recoil 하세요. (유튜브)](https://www.youtube.com/watch?v=0-UaleJZOw8)

- Art.zip 프로젝트를 하면서 Recoil 을 너무 제대로 사용하지 못한 것 같아서, 컨퍼런스를 통하여 간단하게 Recoil 의 컨셉을 확인하고, 어떤 식으로 사용하는지 구경하였다.
- 🌧 발표의 첫 부분에 상태 관리 라이브러리에서 어떤 패턴(이렇게 표현해도 되나?)을 사용하느냐에 따라서 해당 라이브러리와 단점?을 간략하게 설명하는데, 이 내용을 보고 각 패턴에 따른 상태관리 라이브러리에 대해서 공부 해야겠다고 느꼈다!
- Recoil 은 상태를 담는 아주 작은 단위의 atom 만이 제공되고, selector 라는 순수 함수를 이용하여 상태에 대한 set 작업을 한다. 상태가 변경이 되면 atom 을 참조하는 컴포넌트만 리렌더링 된다.(⛆ 보통 Context API 에 대비되는 Recoil 의 가장 큰 장점을 해당 내용으로 뽑는 경우가 많은 것 같다)
- 또한 Recoil 의 상태들이 상호의존성을 가질 때, 데이터 흐름에 따라서 상호의존성을 가진 컴포넌트들을 유기적으로 관리한다.
  - selector 내부에서 다른 atom 이나 Selector 를 구독함으로써 다른 데이터에 대한 의존성을 정의한다.
  - 그리고 selectorFamily 를 사용하여 기존에 구독하고 있는 값을 받을 수 있다.
- RecoilState 가 비동기 통신을 하던 중 오류가 발생하면 `<RecoliRoot />` 영역 전체가 렌더링 되지 못하는 문제가 있다. 이를 해결하기 위하여 Recoil 에서는 1. React 의 에러 바운더리로 감싸주거나 (Suspense 를 이용) 2. Loadable 을 이용하여 값이 있을 때, 로딩 중 일 때, 에러가 발생했을 때를 구분하해서 처리 하는 방식으로 에러 핸들링을 하는 것을 권고한다.

  - 🌧 Art.zip 프로젝트를 하면서, 가장 애먹었던 이슈 중 하나가 RecoilRoot 영역 내부에서 문제가 발생하였을 때 그 안의 컴포넌트 트리가 만들어지지 못하던 이슈였다. ( [관련 디스커션](https://github.com/prgrms-web-devcourse/Team-BackFro-ArtZip-FE/discussions/169))  당시에는 서버 사이드  쪽에서 예외 처리를 해주는 방식으로 해결했었다.  Recoil 에서 제공하는 방식을 Atom 정의 부에서 사용할 수는 없을까? Loadable 에 대해서는 내가 잘 모르지만... 저 방식 대로라면 Client 쪽에서 예외를 처리하는 방법인 것 같아서 Next.js 와 같은 서버 사이드 프레임워크나 라이브러리에서는 서버 측에서 로직을 따로 작성해야 할 것 같다.

- **🌧** Art.zip 프로젝트를 하면서 가장 아쉬웠던 점 중 하나가, Recoil 을 도입했음에도 불구하고 Recoil 을 사용하는 쪽이 전역 로그인 상태 뿐이라는 점이였다. Atom 을 작게 나눠서, 상태들을 컴포넌트 묶음에 대한 작은 데이터 베이스 처럼 사용하고 싶었는데..... (특히나 댓글이나 모달 부분)
- 🌧 컨퍼런스에서 각기 다른 컴포넌트에서 이루어지는 전역적인 UI 상태 (ex 모달 열고 닫기, list 상태들) 등을 상태 관리를 해야 하는 대표적인 예시로 들었다. 내가 그 동안 Recoil 과 같은 전역 상태 관리 라이브러리를 제대로 사용하지 못했다는 생각이 들었는데, 그 이유를 생각해보면  "상태"라고 해서 너무 애플리케이션의 "내용" 에만 집중했던 것 같다. 어쨌든 간에 "프론트엔드" 란 애플리케이션의 "내용"과 "형식" 중 "형식" 을 먼저 집중하는 직무이기 때문에, "형식" 을 보여주는 UI 적인 부분에 초점을 맞출 필요가 있겠다는 생각이 들었다.
