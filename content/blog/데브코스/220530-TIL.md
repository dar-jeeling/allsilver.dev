---
title: '220530 TIL'
date: 2022-05-31 04:37:45
tags: ['TiL']
category: '데브코스'
draft: false
---

**⛅ = 내 생각 비중↑**

## Today I Learned

### 사용 사례 \- 검색

- 보통 검색은 backend에서 처리하지만, client에서 검색을 구현하는 경우도 있음 (간단하게 고차함수 filter를 사용해서 구현함)
- **『컴포넌트가 도메인과 강하게 얽혀있다』 vs 『컴포넌트의 범용성』**


    컴포넌트가 도메인과 강하게 얽혀있다면(도메인에 따른 prop를 받는다면), 컴포넌트가 어떤 역할을 하는지 쉽게 알 수 있지만 범용성이 떨어진다.

     반대로 컴포넌트가 범용성이 높아진다면, 너무 심하게 추상화가 되어 어떤 컴포넌트인지 알아보기 힘들 수가 있다.

    → 따라서, **컴포넌트가 얼마나 구체적인가** 는 본인의 선택이다. (어쨌든 컴포넌트는 생각이 들 때마다 리팩토링 하면 됨)



    **⛅ 이러한 문제는 나중에 context API를 사용할 때도 고려해야한다. context API를 사용하게 되면 전역적으로 상태를 관리하게 됨으로써, 상태관리가 편하고, nesting 된 컴포넌트에게 데이터를 전달하기 쉬워지지만, 컴포넌트가 이 context와 얽혀있게 되면서 컴포넌트의 재사용이 어려워 진다.**

- 브라우저에서 클립보드 사용하기

```javascript
onClick={() => navigator.clipboard.writeText(anything)
```

### Context API

- conetext API는 전역 상태 관리를 위한 api이다. 이게 무슨 말이냐면, 리액트에서 component는 트리 구조로 이루어져있으므로 상태가 단방향(상위에서 하위, 부모에서 자식)으로 흐르게 된다. 이 때문에 어떤 상태를 넘겨주고자 할 때 중간에 불필요한 상태를 넘기면서 하위까지 상태를 전달해주어야한다. ( 이 말은 중간 컴포넌트들을 쓸데없이 중계자 역활로 사용한다는 것과 같다, 이런 현상을 Props Drilling 이라고 한다.)
- 따라서 context API를 이용하여, 전역 상태를 추가 함으로써 중간 컴포넌트들을 중계자 역활로 사용하지 않아도 된다.
- **⛅ Context API의 동작은 일종의 pub-sub 패턴이라고 생각할 수 있을 것 같다. 우선 Context를 만드는 곳에서 publisher를 리턴하면( 경우에 따라 subscriber 도 함께 리턴), 이 publisher를 사용하고 싶은 컴포넌트에서 이 publisher를 subscirbe하여 사용한다. 이 subscirber를 consumer라고 대응시키면 pub-sub 패턴과 상당히 비슷한 양상을 보인다.**
- **하지만 context API를 무분별하게 사용한다면 성능 이슈가 발생할 수 있다. 왜냐하면 provider가 변경되면 consumer와 관련된 컴포넌트들이 다시 렌더링 하게 되고, 컴포넌트가 이 context와 강하게 결합되게 되면서 컴포넌트의 재사용성이 힘들어진다. 즉 컴포넌트가 context에 종속되고 이 컴포넌트가 독립적으로 존재할 수 없게 된다. 따라서 리액트 공식문서에서는 context를 꼭 필요할 때만 사용하고, 컴포넌트 합성을 고려해보라고 제시한다.**

## Upload 컴포넌트

- 파일 등록(업로드)을 위하여 input 태그를 사용한다. 이 때, type은 file로 한다.

  input 태그의 style 에 관한 문제로 인하여 toggle 컴포넌트를 만들었던 것 처럼 input 의 기본 스타일을 숨기고 다른 스타일을 보여준다.

- 따라서, 숨겨 놓은 input 태그에 접근하고, 태그의 내용을 변경하기 위하여**useRef**훅을 이용하여야 한다.
- **⛅** 즉, 다른 태그의 이벤트를 통해서 useRef를 사용하여 useRef에 등록해놓은 input 태그에 접근하도록 하고 input 태그의 기능(파일을 올리는 기능)을 사용하는 방식으로 작동한다.
- ⛅ input 태그가 가지고 있는 선택의 상태(이 컴포넌트에서는 파일을 가지고 있는 상태)는 input 태그 내에서 콜백을 이용해서 전달한다.
- 이 상태를 자식 컴포넌트에 넘기기 위해서 다음과 같은 기법을 사용할 수 있다.

```javascript
{
  typeof children === 'function' ? children(file) : children
}
```

즉, children을 jsx르 반환할 수 있는 함수로 받을 수 있게 하는 것이다.

#### Drag & Drop

- Drag & Drop 을 위하여 Drag 이벤트 네 가지를 다루어야 한다.

  \- **DragEnter :** Drag를 통해서 컴포넌트 내부로 들어왔을 경우를 뜻한다.

  - **DragLeave :** Drag를 하다가 컴포넌트 밖으로 나갔을 때를 뜻한다.

  \- **DragOver :** 이벤트 전파를 막기 위한 부분이다. 브라우저 기본이벤트를 통해서 파일을 드래그 했을 때 새창이 열리거나 하는 일을 방지한다.

  - **Drop :** 파일을 컴포넌트 위에 두었을 때의 처리이다.

- 네 가지 이벤트에서 공통적으로 브라우저의 기본 동작을 막고(preventDefault), 이벤트 전파를 막아야한다. (stopPropagation)

### Badge 컴포넌트

### Icon 컴포넌트

## 회고

- 리액트 공식문서를 조금씩 병행하면서 읽고 있는데, 순서대로 읽지 않아서 그런지... 이해하기 힘든 부분이 있다. 제일 이해하기 힘들었던 부분은 context API 부분에서 "context를 사용하면 컴포넌트를 재사용하기 힘들어지기 때문에 꼭 필요할때만 사용하라" 였다. (하지만... 보통 contextAPI를 컴포넌트의 재사용성때문에 사용하는걸로 이해하지 않나..?)

  우선은 context를 사용하는 것 자체가, 어떤 컴포넌트와 context의 coupling을 만드는 것이므로, 이 component가 이 context에 종속된다. 라는 걸로 이해를 하였는데 이것보다 더 어려웠던 점은

  **여러 레밸에 걸쳐서 props 넘기는 걸 대체하는 데 context 보다 컴포넌트 합성이 더 간단한 해결책일 수도 있다.**

  라는 말이였다. 코드에서 최상위 컴포넌트에서 사용하고 싶은 컴포넌트를 component를 props로 넘겨주는 방식으로 (안쓰고 싶으면 사용할 때 안넘겨주면 됨) 사용하는 것 같은데(강의에서도 강사님이 **컴포넌트를 한 번 감싼 컴포넌트** 라고 언급하심)... 이는 코드를 한 번 짜봐야할 것 같다. (프로젝트 때 활용하고 팀원에게 한 소리를 들어보면 실감나지 않을까? 미리 죄송합니다

## Reference

[https://ko.reactjs.org/docs/context.html#gatsby-focus-wrapper](https://ko.reactjs.org/docs/context.html#gatsby-focus-wrapper)

[Context – React\
\
\
A JavaScript library for building user interfaces\
\
\
ko.reactjs.org](https://ko.reactjs.org/docs/context.html#gatsby-focus-wrapper)

[https://www.youtube.com/watch?v=sqz45pnvJHg](https://www.youtube.com/watch?v=sqz45pnvJHg)
