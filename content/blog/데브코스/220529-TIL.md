---
title: '220529 TIL'
date: 2022-05-29 21:29:56
tags: ['TiL']
category: '데브코스'
draft: false
---

## Today I Learned

### 딥다이브 스터디 \- 25장 클래스

- 클래스는 자바스크립트의 일종의 새로운 객체 생성 방식이다. 기본적인 원리는 생성자 함수이고, class 자체의 prototype 역시 Function.prototype이기 때문에 **클래스는 일종의 『특별한 생성자 함수 객체』** 이다.
- 따라서 클래스가 인스턴스를 생성하는 방식 역시, 기존 클래스기반 언어(JAVA, C++)의 그 방법보다는 원래의 자바스크립트 방식과 같다. 따라서 **자바스크립트에서 클래스 역시 프로토타입 기반의 객체 생성 방식** 이다.
- 단, 클래스는 constructor 로써의 기능을 강화하였다. 따라서 객체 지향을 위해서 사용할 수 있는 기능이 풍부하다. (예: super, new에 대한 방어, extends를 이용한 클래스 확장 등)
- 또한 ES6에서 추가된 기능인 만큼, **선언되는 방식은 let, const와 비슷** 하다. 따라서, 호이스팅이 되긴 하지만 TDZ에 진입하는 방식이다.
- 기본적으로 클래스와 생성자함수의 객체 생성방식은 다음과 같이 매핑하여 생각한다.


    **1\. 생성자 함수 내부에서 this 키워드를 사용한 프로퍼티의 정의 - 클래스 내에서 constructor 내부에서의 프로퍼티 정의**

    **2\. 생성자 함수 객체 자체에 프로퍼티를 추가 - 클래스 내부에서 static 메서드의 선언**

    → 이미 용어부터 static method라고 한다. static method는 인스턴스와 상관없이 함수 객체 자체가 가지는 메서드이다.

    **3\. 생성자 함수의 prototype 프로퍼티가 가리키는 객체(생성자함수.prototype)을 통하여 상속받을 메서드의 정의 - 클래스 내부에서 메서드를 정의**

    → 클래스에서 객체 지향을 구현하기 위한 가장 강력한 기능 중 하나라고 생각한다. 또한 클래스의 경우 이 메서드가 메서드 축약 표현(딥다이브에서는 메서드 축약 표현으로 정의된 메서드가 진정한 메서드라고 표현한다)으로만 선언이 되어야 하는데, 이는 [[HomeObject]] 내부 슬롯을 위한 것으로, 이 내부 슬롯을 통하여 super를 구현함으로써 클래스의 확장으로 만들어지는 상속관계를 더욱 편하게 구현할 수 있다.

- 생성자 함수에서 prototype 을 통해서 객체 지향을 구현하는 것은 다소 가내수공업적인.... 느낌이 있으나 클래스의 경우 훨씬 편리하게 사용할 수 있다. 이러한 특징은 **특히나 extends를 통해서 클래스를 확장할 때 체감할 수 있다. (extends 키워드는 클래스 뿐만이 아니라 prototype 상속을 위한 것으로는 모두 사용할 수 있다.)**

  간단하게 설명하자면 부모 클래스(수퍼 클래스)인 Parent가 있다고 하자. 이 클래스를 확장해서 자식 클래스(derived)인 Child를 만들 때, extends 키워드를 통해 확장한다.

  extends 키워드를 통해 확장하면 class 자체 (함수 객체도) 프로토타입으로 연결이되지만, 이와 동시에 클래스가 생김으로써 만들어지는 클래스(함수 객체)에 대한 prototype(프로퍼티에 바인딩된) 객체 역시 프로토타입으로 연결된다)

  최종적으로 Child에서 인스턴스가 만들어진다고 할 때, 이 인스턴스는 Child를 통해 new 키워드로 만들어졌으므로 프로토타입이 위의 Child.prototype으로 연결이 되는데 이 객체 역시 Parent.prototype으로 프로토타입이 연결되어져 있다.

  이렇게 함으로써 상속관계를 좀 더 명료하게 사용할 수 있다.

- 여기서 주의할 것은 서브클래스에서 인데, **서브클래스에서는 객체를 생성할 수 없다. 이 말은 처음 객체를 생성하기 위해서 빈 객체에 this를 바인딩하는 과정을 할 수 없다는 것을 뜻한다.** 따라서 이를 부모 클래스에서 먼저 해주고 나서, 부모 클래스에서 바인딩된 this를 사용하여 서브클래스에서 나머지 프로퍼티들을 바인딩하는 방식을 사용하여야 한다.

  이를 통해 서브클래스에서 에러가 나는 문법들을 설명할 수 있다. super를 통하여 부모 클래스의 constructor를 호출하지 않으면 this를 영영 찾을 수 없기 때문에 super 호출 전에 this를 호출하면 에러가 나는 것이다.

- **단, 인스턴스를 누가 생성했냐? 라고 하면 서브클래스가 인스턴스를 생성한 것으로 한다. 따라서 new.target이 서브클래스 연결된다.**
- 위에서 말했듯이 extends의 기능을 그림으로 나타내면 다음과 같다. **프로토타입의 상속관계를 확장해준다, 즉 클래스(생성자 함수) 간의 프로토타입 체인 뿐만이 아니라 인스턴스의 프로토타입 체인까지 만들어준다**... 정도로 생각하면 된다.

![](https://blog.kakaocdn.net/dn/bDHGtQ/btrDmWHeOkV/Jm81PZOhbdvxAZ41TmMNUK/img.jpg)extends 키워드를 통해서 Parent를 상속받는 Child 클래스를 만들고, Child 클래스를 통해서 instance를 생성하였다.

- 이러한 클래스를 좀 더 편하게 사용하기 위해 다양한 문법들이 제안되었다. (tc39)

  \- # 를 통하여 private 접근자 속성을 사용할 수 있다.

  \- constructor에서 프로퍼티를 선언하지 않아도, 클래스 내부에서 바로 프로퍼티를 선언할 수 있다.

## 회고

#### 오늘 하루에 대하여

- 복습기간 전까지 여러가지 이유로 진짜 힘들었는데, 조금씩 재활을 하고 있는 것 같다. 비록 타이밍 좋게 복습기간 다음날에 제대로 체해서 하루종일 누워있느라 미리 들은 강의는 말짱 도루묵이 되어버렸지만ㅋㅋㅋㅋ(그래도 안밀렸다...)

  다음 주 내로 다시 여유분을 만들어두고 싶다.

- 프로젝트에 대한 회의를 하였다. 예전에도 프로젝트를 해본 적은 있었는데, 그 때는 프론트엔드가 나 혼자 밖에 없었고, 다른 파트를 맡으신분들역시 공부하면서 만드느라 정신이 없어서 기능적인 부분(어떻게x 뭘만드냐o)을 제외하고 협업이라는 것을 많이 느꼈는데, 이제는 같은 프론트엔드끼리 뭔가를 만들어야하기 때문에 팀원끼리 사소한 부분을 더욱 잘 맞추어야할 것 같고, 코딩 외적인 부분에서 제대로 머리를 맞대어야함을 느낀다.


    소프트웨어 공학을 통해서 프로젝트를 만들기전에 Requring Engineering이라던가, Use-case modeling, Scenario, testing 기법등을 배웠는데, 지금까지 배운 소프트웨어 공학적 지식과 방법론들을 간접적으로 나마 적용시킬 수 있을 것 같아서 기대가 된다. 물론 어디까지나 약간씩만 차용하여야하고, 아마 내가 배운 소프트웨어 공학은 컴퓨터의 역사로 따지면 대략 고생대 쯤의 내용일 것이므로 팀원들이나 멘토님께 많은 조언을 얻어야 한다고 생각한다.

#### 오늘 배운 내용에 대하여

- 그동안 문법적 설탕이라고 뒤로 계속 미뤄왔던 클래스에 대해서 본격적으로 공부를 하였다. 클래스를 배우면서 왜 문법적 설탕인지 알 것 같기도 하면서(왜냐면 이름만 클래스지 작동하는 방식이 생성자 함수와 전혀 다를게 없다), 클래스의 기능이 상당히 강력함을 느낄 수 있었다. 특히나 난 validation을 잘 못하는 편인데, 클래스를 통해서 조금 더 프로그램을 견고하게 사용할 수 있을 것 같다.
- 당연히 클래스는 함수의 constructor의 기능을 강화하였으므로.. 무언가를 생성한다 라는 목적으로는 클래스를 안 쓸 이유는 없는 것 같다.
- 그런데 React의 경우 초기에는 클래스 컴포넌트를 사용하다가, 이제는 함수형 컴포넌트를 권장한다는 것을 들었는데, 대략 Hook 이 도입되고 이를 활용하기 위해서 함수형 컴포넌트를 사용하는 것 같다. 그렇다면 Hook을 클래스 컴포넌트에서는 사용을하지 못하나...? 내가 아직 Hook에 대해서 제대로 알아보지 않았으므로.... 내일 바로 알아보도록 하겠다.

> [React Function Components with hooks vs Class Components | stackoverflow](https://stackoverflow.com/questions/53062732/react-function-components-with-hooks-vs-class-components)
