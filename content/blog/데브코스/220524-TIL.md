---
title: '220523 TIL *수정*'
date: 2022-05-24 03:05:04
tags: ['TiL']
category: '데브코스'
draft: false
---

⛅  은 내 생각의 비중이 높은 내용

## Today I Learned

#### React

\- 로고와 React 라는 말에서 알 수 있듯이 '화학 반응'이라는 말에서 따와서 이름을 지었다. 즉, Reactive Programming으로 프로그램을 구성한다.

⛅ 즉, 상태를 관찰하고 있다가 변화가 발생한다면 그곳에서 연산을 수행한다. 이 말에서 SPA의 핵심이라고 하는 "필요한 부분만 렌더링한다" 라는 말이 생각났다. 즉, 상태를 관찰하고 있다가 상태를 변경하고 있는 곳에서만 렌더링하는 방식을 사용한다고 이해하였다. 또한 Virtual DOM도 떠올랐다. 이것도 DOM tree에서 변경된 부분만 렌더링하게 하는 방식...이라고 들었는데, 어쨌던간에 React 가 강조하고 있는 부분인 것 같다.

\- 리액트도 뷰와 마찬가지로 MVC 패턴에서 View 만을 관리한다. 이 때, View를 컴포넌트 시스템으로 관리하게 되는데, 컴포넌트는 트리 구조로 이루어진다. 이 컴포넌트는 서로 데이터와 메세지를 주고 받게 되는데, 중요한 것은 **데이터가 단방향으로 흐른다는 것** 이다.

⛅ 기본적으로 데이터가 한 쪽 방향으로만 흘러야한다는걸 바닐라 시간에 배운것..... 같다? 그런데 생각해보면 Vue를 배울 때는 양방향 데이터 바인딩이 가능했던 것 같은데, React에서는 자체적으로 이런 방식까지 막은 것일까?

⛅ 그렇다면 양방향 데이터 바인딩이라는건... 좋지 않은 패턴일까? 물론 데이터가 양쪽으로 흐른다는 말 부터... 복잡해진다는 느낌이 없지않아있지만... 여기에 대해서는 추가적으로 조사가 필요할 것 같다.

\- 리액트는 Virtual DOM 을 사용함으로써, 별다른 최적화 없이 빠른 성능을 낸다. 프레임워크나 라이브러리는 최소한의 노력으로 최대의 효율을 내기 위함인 것이라는 것을 기억해두자.

#### JSX

\- js 코드 안에 htnl 처럼 보이는 부분이 있는데, 이건 가상DOM을 정의한 것이며 이런 포맷을 jsx라고 한다.

⛅  innerHTML과 구분되어진다. innerHTML은 실제로 DOM을 갈아끼는거라고 하면 jsx를 사용하는 것은 가상돔을 정의하는 것이라고 생각된다. 이는 바닐라에서 하나하나 DOM을 조작하는 여러 메소드를 사용하는 것을 더욱 더 편리하게 만든 방식처럼 느껴진다.

⛅ 개인적으로 React를 사용하면서 편했던 점은 한 파일안에 html, css, js의 구조를 모아놓을 수 있었다는 점이다. 또한 어디선가 (바닐라였던거같음) 코드에서 마크업 구조가 보이는게 더 보기 좋은 코드라는 말을 들었는데, 리액트는 이를 jsx로 구현해놓은 것 같다.

\- html 과 몇가지 다른 점이 있다. class 대신 className이라고 쓴다던가?

\- 또한 리액트 컴포넌트들이 jsx 구조를 리턴하는 방식으로 이루어지는데, 이 때 한 컴포넌트 내에서는 최상위 요소를 하나 리턴하여야한다. 즉, jsx에서 최상위 요소가 하나여야만 한다는 뜻이다.

⛅  여기서도 Vue와의 차이점이 느껴졌다. Vue의 경우에는 한 컴포넌트 내에서 최상위 컴포넌트가 여러 개 일 수 있었고, 데이터를 보내 줄 때도 특별한 방법을 사용하였다.

⛅  이는 Virtual DOM 에서 컴포넌트 변화를 효율적으로 감지하기 위한 규칙이라고 한다... 생각해보면 가상 돔이 트리구조로 이루어져있고, 이 트리를 구성하는 노드들이 하나의 컴포넌트들이고, 이 컴포넌트가 하나의 요소로 리턴이 되는것이 트리 구조 내에서도 자연스럽게 보인다.

\- jsx에서는 표현식을 사용할 때, {} (중괄호)로 감싸서 사용한다. → 이를 통해 동적으로 웹이 작동할 수 있다.

\- 조건부 렌더링의 경우, and 조건(&&)을 이용하거나 3항 연산자를 사용한다.

\- 반복문의 경우 map을 주로 사용하는 것 같다.

⛅  강의 초반에 명령형 프로그래밍에 대해서 잠깐 말을 했고, 자바스크립트를 배우면서 선언적인 프로그래밍이 계속 강조되는 것 같은데, 리액트에서 map 을 주로 사용하는 이 방식이 자바스크립트의 선언적 프로그래밍 방식과 함수형 프로그래밍 방식에 특화되었다고 생각하였다. ( 관련된 아티클을 읽은 기억이 있는데 아티클 링크를 못찾는중 ㅡㅡ...)

#### 컴포넌트

\- HTML, CSS, JS로 이루어져있으며 상태와 이벤트를 가지는 한 덩어리. 트리 구조로 이루어져있으며 앞에서 말했듯이 **데이터는 상위에서 아래로만 흐른다.**

\- 컴포넌트의 핵심은 **재사용이 가능한 컴포넌트를 만드는 것** 이다. 즉, 추상화를 잘해서 재사용이 될만한 공통점을 찾아보자.

\- 컴포넌트는 함수를 정의함으로 만든다. 바닐라 JS를 배울 때, 컴포넌트 만들던 방식과 매우 유사하다.. 옛날에는 클래스를 이용해서 만들었다고 하는데, 점점 함수로 만드는 것을 권장하였다고 한다.

⛅  class가 JS의 일종의 Syntax Sugar라서 그런게 아닐까...? 라는 생각을 한다. 위에서 말한 반복문 렌더링의 방식에서도 map을 사용하는 등을 보면 React는 상당히... 자바스크립트의 특성을 살리는 (당연함) 방향으로 디자인되었다고 생각한다.

**(5.30 React Hook에 대한 내용을 찾아봄)**

### React Hooks

\- use라는 prefix가 붙어있는 함수들을 hook이라고 부르고, 이 hook을 이용하여 함수 내의 상태나 라이프사이클 등을 관리할 수 있다. ⛅ 사실상 클래스형 컴포넌트에서 함수형 컴포넌트로 전환되게된 계기이다.

\- 이 React Hook을 통해서 주로 lifeCycle과 state, custom hook을 사용할 수 있다. 오늘 배운 useState와 useEffect는 상태에 관련한 Hook이다.

⛅ **React에서의 클래스형 컴포넌트와 함수형 컴포넌트의 차이점 때문이다. 초기에는 리액트의 Life Cycle 관련 함수나 상태에 관련된 부분을 클래스형 컴포넌트에서만 사용할 수 있었고 함수형 컴포넌트에서는 사용할 수가 없었다.그렇기 때문에 클래스형 컴포넌트를 이용하다가 이후에 Hooks을 도입하게 되면서 함수형 컴포넌트를 사용하게 되었다.**

⛅ **클래스형 컴포넌트를 사용하는 경우, 코드가 길어질 수록 복잡성이 올라가고, 코드의 양이 함수형 컴포넌트에 비해 길어진다. 이는 코드만 비교해서도 확인할 수 있고, Babel을 이용해서 컴파일 할 때는 차이점이 훨씬 극명해진다.** **코드의 복잡성과 길이를 통해서 오는 성능저하는 덤이다. (그 외에도 내부에서 더 느리게 동작하는 원인이 있을 것 같음)**

⛅ **결론적으로 함수형 컴포넌트와 Hook의 조합을 통하여, 그동안 클래스형 컴포넌트에서만 가능하였던 기능을 사용함과 함께, 더 간결하고 심플한 코드와 더 빠른 성능을 얻어낼 수 있으므로 함수형 컴포넌트를 사용하게 되었다.**

\- 컴포넌트는 props를 인자로 받아서, 상위 요소로 부터 데이터를 전달 받는다. 또한 컴포넌트 내부에서 defaultProps를 이용할 수 있고, **컴포넌트이름.defaultProp = { props 정의 ... }** 와 같은 방식으로 사용한다.

\- 타입 제한도 할 수 있다! **prop-types** 에서 **PropTypes** 를 import 하여 사용한다. 이 후,

**컴포넌트이름.propTypes = { onClick : PropTypes.func; }** 과 같은 방식으로 사용한다.

\- 또한 상위 컴포넌트에서 하위 컴포넌트 사이에 값을 넣었다면, ( **<Component>어쩌고저쩌고</Component>** 에서 어쩌고저쩌고의 부분) 이 부분은 **chlidren** 이라는 prop으로 들어오게 된다. 또한 이 PropTypes를 통하여 타입을 정해줄 때는 node 라는 타입을 이용한다.

\- 이 prop이 반드시 넣어야하는 prop 이라면 **isRequired** 라는 값을 사용한다.

#### useState

\- React 컴포넌트에서 지역 상태를 관리하기 위하여 사용하는 Hook이다.

**const [상태, 이벤트에 따라 상태를 바꿔줄 함수(대체로 set상태)] = useState(initialState);**

#### useEffect

\- 인자로 넘겨준 변화가 있을 때 감지하여 반응한다.

- **useEffect( 어떻게 반응하는가 , 감지하는 데이터들(배열형태) )**

\- 컴포넌트의 lifecycle 처럼 활용할 수도 있다. 예를 들어서 두번째 파라미터에 아무것도 넣지 않으면 **컴포넌트가 처음 로드될때 실행된다.**

\- 이 성질을 이용해서, api를 호출하는 등으로 사용할 수 있다.

\- useEffect에서 return 을 하는 경우에는 컴포넌트가 제거 될 때 실행된다. 예를 들어서 전역적으로 이벤트를 걸었을 때 removeEventListener 등을 할 때 주로 사용한다.

#### useRef

\- useRef는 **DOM에 직접 접근할 때** 나, **지역 변수를 사용할 때 사용** 한다.

\- useState와의 차이는, **useState** 의 경우 **값이 변경될 때 다시 렌더링** 을 하지만, **useRef** 는 **값이 변경되더라도 다시 렌더링을 하지 않는다. (즉, useRef의 경우 다시 렌더링하지 않을 지역상태를 위해 사용)**

\- DOM 에 직접 접근할 때.. 라는 말은 그 DOM에서만 활용할 수 있는 메서드등을 사용할 때.. 등을 말한다.

\- 단일 요소 뿐만이 아니라 컴포넌트에서도 사용한다. (⛅ 이래서 컴포넌트가 최상위 요소 하나만을 리턴하게 되는 걸까?) 이는 **React.forwardRef라는 메서드를 사용하며, .forwardRef( (props, ref) ) 의 형태로 사용** 한다.

\- 컴포넌트에 React.forwardRef를 사용하고, 바깥쪽에 이 컴포넌트의 어트리뷰트로 ref를 넣으면 이 컴포넌트로 연결시켜 준다.

## 회고

- 쓰다가 마이너스 에너지만 잔뜩 발산해서 지웠음. 다시 꾸준히 작성해보겠습니다 화이팅!
- 지속가능한 배움을 위해서 고민 중

### 번외

몇 가지 찾아보고 싶은 주제가 있는데... 지금 알아보면 내일 문제가 생길 것 같으므로 잠시 메모를 해둔다.

- 각 라이브러리와 프레임워크에 따른 리스트 렌더링 방식 (아티클 링크 찾기)

[https://velog.io/@lky5697/how-to-render-a-list](https://velog.io/@lky5697/how-to-render-a-list)

[(번역) React, Angular, Vue, Svelte에서 리스트를 렌더링하는 방법\
\
\
어떤 접근 방식이 가장 좋습니까?원문 : https://javascript.plainenglish.io/rendering-a-list-in-react-angular-vue-and-svelte-a2ea987f0c21이 글에서는 가장 많이 사용되는 4가지 프레임워\
\
\
velog.io](https://velog.io/@lky5697/how-to-render-a-list)

- atomic design 과 컴포넌트 분류 패턴에 대하여
- useState(0); 처럼 인자로 들어가는 값은 무엇을 의미하는가 : 그냥 초기값이였음
- 전역 이벤트를 해제해야한다?

## Reference

[https://www.youtube.com/watch?v=C26vJqelKlA](https://www.youtube.com/watch?v=C26vJqelKlA)
