---
title: '220526 TIL'
date: 2022-05-28 18:15:53
tags: ['TiL']
category: '데브코스'
draft: false
---

⛅ **= 내 생각 비중↑**

## Today I Learned

### 컴포넌트 설계 \- Atomic Design

![](https://blog.kakaocdn.net/dn/V7jGc/btrDuvA4gHm/Q3X60YutvGwUtKjTbkoyfk/img.gif)출처 : TOAST UI (https://ui.toast.com/weekly-pick/ko\_20200213)

⛅ 전날의 강의에서 강사님이 현재 강사님의 스타트업의 경우 Atomic Design 을 기반으로 컴포넌트르 개발하고 있다고 하셨다. 또한, 앞으로의 강의가 직접 컴포넌트를 만들어가는 것이기 때문에, Atomic Design Pattern이 무엇인지 간략하게 알아두면 앞으로 만들 컴포넌트의 방향성을 다 잡을 수 있다고 생각하였다.

- 대략적으로, atom 이라는 말에서 알 수 있듯이, 가장 작은 컴포넌트를 atom으로 만들고, 이 atom을 통하여 상위 컴포넌트를 쌓아가는 방식이다. 최소 단위를 atom으로 하고, 이 atom이 보여서 Molecules, 그리고 이 Molecules가 모여서 Organisms이 되고, 이 Organism이 모여서 Templates이 된다.
- **atom** 은 **디자인과 기능의 최소 단위**이다. 대표적으로 Label, Text, Container, Button, Icon 등이 있고, React(3) 강의에서 만든 컴포넌트(Text, Header, Image, Spacer, Spinner, Toggle 버튼) 들이 이에 해당된다고 할 수 있다.
- **molcules** 는 atom 보다 한 단계 위의 컴포넌트로, 입력 폼(Input forms), 네비게이션바(Navigation), 카드(Card) 등을 말할 수 있다. 이번 강의 (React(2)) 에서 만들어 본 **로그인, 회원가입 폼** 이 여기에 해당된다.
- **organisms** 는 molcules를 묶어서 관리하는 컴포넌트이다. 예를 들면 입력 폼과 함께 헤더를 감싸는 식으로 만든 흔히 사이트에서 헤더라고 말하는 부분이나,  카드 여러 개가 모여있는 그리드를 예로 할 수 있다.
- **template** 은 이 organisms이 모여있는 것이고 page 보다는 낮은 단위이다. 위의 그리드들을 묶어서 하나의 템플릿을 만들 수 있다.
- 이러한 Atomic Design Pattern 으로 하위 컴포넌트 부터 차곡차곡 쌓아낳아감으로써 컴포넌트의 재사용성을 최대화 할 수 있다.
- 단, atomic design pattern의 경우, 상위 컴포넌트에서 문제가 생기면 하위 컴포넌트로 계속해서 내려가서 문제를 수정해야한다. 따라서, 컴포넌트가 파편화 되고, 다소 과정이 난잡하다. 또한 상위 컴포넌트가 하위 컴포넌트에 의존을 하는 구조가 만들어지기 때문에, 하위 컴포넌트에서 문제가 생기면 그 하위 컴포넌트에 종속되어있는 상위 컴포넌트에 모두 문제가 발생한다.
- ⛅ 또한 atomic design pattern의 경우 "추상화"를 강조하였으므로, 결국 원자에 해당하는 컴포넌트들이 명확하게 기능으로 구분이 되지 않는 문제점이 있다.

⛅ 얼마전에 다른 멘토님과 만났을 때, atomic design이 **상당히 추상적이게 느껴진다** 고 이야기를 했었다. 추상화가 많이 되어있을 수록 **컴포넌트의 재사용성이 높아진다.** 하지만 앞에서 "추상적이게 느껴진다"라고 말을 했듯이 이 **러한 추상화는 "이해하기 힘들다"와 "그래서 어떤 기능을 하는지 구분이 어렵다"라는 단점이 있고, 이것이 아토믹 디자인 패턴의 장단점과 정확하게 일치한다**....

⛅ 즉, atomic design pattern은 컴포넌트의 **추상화** 에 중점을 준 방법론이라고 생각한다.

### 컴포넌트 스타일링

- CSS In JS 를 통하여 컴포넌트 스타일링을 할 수 있다. **CSS In JS란 JS로 만든 스타일 코드가 CSS로 만들어지는 것** 을 뜻한다. 여러가지 라이브러리로 이를 구현할 수 있는데, 강의에서는 주로 **emotion** 을 사용한다.
- 또한 emotion 을 통하여 styled-component 를 이용할 수 있다. 이를 통해 스타일이 적용된 컴포넌트를 바로 만들어 줄 수 있다.

⛅ Vue를 배울 때도, 하나의 Vue 컴포넌트안에 template 으로 표현한 HTML(과 비슷한)코드, JS 영억, style 영역이 한 파일에 나누어져있었다. 따라서 CSS in JS 또한, **한 파일에 JS, HTML(리액트의 경우 jsx로 구현됨), CSS를 모아두려는 시도** 중 하나이다.

⛅ 이렇게 한 파일에 HTML, CSS, JS를 모아둠으로써**"하나의"**파일에서 **"하나의"**컴포넌트에 대한 내용을 모두 파악할 수 있다. ( **즉 한 파일에서 컴포넌트의 구조를 한번에 파악할 수 있다.**)

⛅ 또한 이러한 시도는 바닐라 자바스크립트를 통하여 컴포넌트를 구현할 때도 사용한다. 왜냐하면 DOM Api를 사용하여 컴포넌트를 이리저리 만들어내는 것보다, 자바스크립트 파일안에서 (innerHTML과 같은 api를 사용하여) HTML 구조를 드러내는게 훨씬 코드의 구조를 파악하기 쉽기 때문이다.

### 컴포넌트의 렌더링에 대한 최적화를 위해 사용하는 Hook

- ⛅ Hook 을 사용하기 위해서, 우리는 함수를 사용하여 컴포넌트를 구현한다.
- 따라서 **컴포넌트를 렌더링 한 다는 것은 jsx를 반환하는 함수를 실행한다** 는 것이다.
- 문제점은 여기서 생긴다. **어떤 컴포넌트가 다시 렌더링하게 된다면 함수가 다시 실행된다는 것** 이다. 그렇다면 **함수 내부에서 선언되어있던 변수들이 매번 다시 선언되거나 실행될 수 있다는 것** 이다.
- 리액트에서는**1.\*\***컴포넌트가 자신의 상태를 변경하거나, 2\. 부모로부터 받은 props가 변경될 때, 또는 3\. 부모 컴포넌트가 변경되면 리렌더링\*\* 되게 된다.
- 이렇게 리렌더링을 통해서 함수 내부에서의 연산이 여러번 일어나는 것들을 막기 위하여  아래와 같은 방법들을 사용한다.

⛅ 즉, 리액트에서 VDOM 을 이용한 최적화로 닿지 않는 부분을 아래의 useMemo, React.memo, useCallback 을 이용해서 최적화 하는 것 같다.

**\+ 아래부터의 pseudo-code는 React 공식 문서에서 가져옴**

### useMemo

```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b])
```

- **useMemo는 최적화를 위한 Hook** 이다. useMemo는 **Memoization 된 값을 반환** 한다.
- ⛅ 예를 들어서 n과 color라는 props을 받고, 1부터 n까지 더한 값을 color 색으로 출력하는 컴포넌트가 있다고 하자. 그렇다면 이 컴포넌트에서는 1부터 n까지 더하는 연산과 색을 변경하는 연산이 있을 것이다. n의 값을 아주 큰 값이라고 생각해보자. 백만...정도라고 생각을 하고, props의 color만 계속 변경해본다고 하자. 특별한 방법을 사용하지 않는다면 color만 변경함에도 불구하고 1부터 백만까지 더하는 연산을 계속하게된다.

  ⛅ 이런 상황에서 useMemo를 사용하자. n과 1부터 n까지 더하는 연산에 useMemo를 사용하게 되면( **useMemo( () => 더하는 연산(n), [n])** ) 더 한 값이 memoized 되므로 불필요한 재연산을 막을 수 있다.

- **useMemo 사용법** : **useMemo( 표현식, [ 종속받는 상태 ])**→ 어떤 상태가 변경되었을 때, 이 표현식을 실행할 것 인가? ⛅ 리액트 공식문서에서 이 표현식이 computeExpensiveValue 라는 것에 주목한다.
- **React 공식 문서에 따르면 useMemo는 성능 최적화를 위해 사용할 수는 있지만 의미 상 보장이 있다고 생각하지 말고, useMemo를 사용하지 않고도 동작할 수 있또록 코드를 작성하라고 권장한다.**

### React.memo

- **React.memo** 는 **부모 컴포넌트가 변경되면 무조건 자식 컴포넌트가 리렌더링되는 현상을 막기 위하여** 사용한다.
- ⛅ **ReactMemo는 자식 컴포넌트(하위 컴포넌트)에 대한 최적화 이다. 따라서 자식 컴포넌트를 감싸는 형식으로 사용한다.**
- **⛅** 같은 props를 가지고 렌더링이 자주 일어날 때 사용하면 좋을 것 같다.

### useCallback

```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b)
}, [a, b])
```

- **useCallback은 memoization 된 callback을 반환한다.** ⛅  즉, 함수를 반환한다.
- ⛅ 함수 컴포넌트가 리렌더링 된다는 것은, 그 안에 있는 함수가 다시 실행된다는 것이고, 따라서 함수 내부에 있는 함수까지 다시 선언된다. useCallback은 이 재 선언을 막기 위하여 사용한다.
- useCallback의 경우, 위의 React.memo 등을 사용하여 최적화한 자식 컴포넌트에 콜백을 전달할 때 유용하게 사용된다.
- 함수가 매번 재 선언된다는 것은 하위 컴포넌트에 그 함수를 넘길 때, 매번 다른 함수를 넘기는 것이다. 즉, props 이 변경되는 것이기 때문에 React.memo를 사용한다고 해도 다시 렌더링되게된다. 하지만, useCallback을 사용하여 함수를 선언 후 재사용하게 된다면, 이러한 불필요한 리렌더링을 하지 않아도 된다.

### Custom Hook

- Custom Hook은 **자주 사용할 수 있는 상태 로직을 별도 사용자 정의 Hook으로 빼서 사용함** 으로써 중복되는 코드를 막을 수 있고 편하게 사용할 수 있다.
- ⛅ 이는 공식문서의 **(클래스 컴포넌트에서)『컴포넌트 사이에서 상태 로직을 재사용하기 어렵습니다』** 를 해결할 수 있는 방안이다. 왜냐하면 이전 클래스 컴포넌트를 사용할 때는, lifeCycle 함수가 반복될때 (예를 들면 계속 같은 데이터를 fetch해야한다던가) 할 때, HOC(Higher Order Component)와 같은 패턴을 통하여 이러한 문제를 해결하려고 시도 했는데, 이 경우 wrapper 객체가 너무 많아 지는 문제점이 있어서 wrapper 객체와 실제로 데이터가 흘러가는 객체를 구분할 수 없고, 엄청난 wrapper 레이어로 둘러쌓여진 구조가 만들어지는(문서에서는 wrapper hell이라고 표현한다) 문제가 있었다.


    하지만 Custom Hook 을 통하여, 상태 관련 로직을 추상화하여 별도로 뺌으로써 컴포넌트 내에서 (굳이 Wrapper 객체를 두지 않아도, 공식문서의 표현으로는 "계층의 변화 없이") 상태 관련 로직을 재사용하게 되었다.

### Storybook

- 컴포넌트를 storybook에 정의하고 실제 제품에 적용하는 방식으로 storybook driven development 라는 기법을 사용할 수 있다. ⛅ 이 후 프로젝트에 적극적으로... 사용하면 좋을 것 같다.

## 회고

- 배운 내용을 접은 글에서 바깥으로 빼고, 내 생각의 경우 ⛅ 를 달아서 통합하는 방식을 사용해보기로 하였다. 내 생각이 어디서 나왔는지에 조금 더 잘 링크해보기 위해서가 목표였고, 조금 빠른 템포로 TIL 을 작성해보고 싶었기 때문이다.
- 매일매일 배운 내용을 착실히 다져야 함을 느낀다. 더도말고 덜도말고 오늘 배운 내용을 확실하게 다지고, 오늘 배운 내용에 대해서 조금만 더 들어가보자.
- 공식문서가 처음에 엄청 안읽혀서 조금 현타가 왔었는데, 어디서든 내용을 한번 찾아보고 다시 읽어보니깐 왜 공식문서, 공식문서라고 하는지 알 것 같다ㅋㅋㅋㅋ 앞으로의 리액트 공부 방향도 각 주제에 대해서 이해가 안되면 찾아보고, 이 내용을 공식문서에서 다시 찾아보는 식으로 공부를 할 것 같다.

## Reference

더보기

[https://www.youtube.com/watch?v=uBmnf_k7_r0](https://www.youtube.com/watch?v=uBmnf_k7_r0)

[https://brunch.co.kr/@skykamja24/580](https://brunch.co.kr/@skykamja24/580)

[아토믹(Atomic) 컴포넌트 디자인 개발 패턴\
\
\
대형 프로젝트를 위한 코드 재사용 최적화 컴포넌트 관리법 \| 대형 프로젝트에서는 최적화된 코드 재사용이 필수입니다. 이를 위해서 대두된 코드 디자인 패턴 중 하나는 바로 아토믹(Atomic) 디\
\
\
brunch.co.kr](https://brunch.co.kr/@skykamja24/580)

[https://ko.reactjs.org/docs/hooks-reference.html#usememo](https://ko.reactjs.org/docs/hooks-reference.html#usememo)

[Hooks API Reference – React\
\
\
A JavaScript library for building user interfaces\
\
\
ko.reactjs.org](https://ko.reactjs.org/docs/hooks-reference.html#usememo)

[https://leehwarang.github.io/docs/tech/2020-05-02-useMemo&useCallback.html](https://leehwarang.github.io/docs/tech/2020-05-02-useMemo&useCallback.html)

[이제는 사용해보자 useMemo & useCallback - 이화랑 블로그\
\
\
이제는 사용해보자 useMemo & useCallback 이제 useState와 useEffect에 완전히 익숙해졌다고 느꼈는데, 컴포넌트 내에서 저 두 개의 hook 만으로도 props나 state를 다루는 로직에 관련된 기본적인 기능을 모두\
\
\
leehwarang.github.io](https://leehwarang.github.io/docs/tech/2020-05-02-useMemo&useCallback.html)

[https://ui.toast.com/weekly-pick/ko_20200213](https://ui.toast.com/weekly-pick/ko_20200213)

[리액트 어플리케이션 구조 \- 아토믹 디자인\
\
\
필자는 처음 프로그래밍을 시작했을 때, 디자인 패턴, 파일구조와 같은 추상적인 프로그래밍의 개념과 중요성을 전혀 몰랐다. 하지만 호텔 관련 어플리케이션을 만들면서 그 중요성에 대해 알\
\
\
ui.toast.com](https://ui.toast.com/weekly-pick/ko_20200213)

[https://ko.reactjs.org/docs/hooks-intro.html](https://ko.reactjs.org/docs/hooks-intro.html)

[Hook의 개요 – React\
\
\
A JavaScript library for building user interfaces\
\
\
ko.reactjs.org](https://ko.reactjs.org/docs/hooks-intro.html)
