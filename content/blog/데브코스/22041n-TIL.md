---
title: '~22041n TIL'
date: 2022-04-14 15:03:36
tags: []
category: '데브코스'
draft: false
---

### 배운 것들

- 비동기 개념
- 자바스크립트에서 비동기 구현 : 콜백함수, Promise, async/await
- fetch

### Highlight

더보기

#### 비동기 처리

우선, 비동기 처리가 무엇이고 왜 자바스크립트에서 비동기를 이렇게나 강조하는지 생각해볼 필요가 있다.

- **비동기 처리**

  『비동기』라는 말에서 짐작할 수 듯이 다른 코드와 다른 위치에서 진행된다고 보면 된다. 이 말을 조금 더 쉽게 해보자면, 어떤 일이 동기적으로 일어난다는 것은 어떤 일이 직렬로 일어난다고 생각하면 된다. 따라서 내가 직렬로 가고 있는 동안, 앞에서 다른 것들이 진행되고 있으면, 그것이 끝날 때까지 기다려야 앞으로 갈 수 있다.

  반면, 비동기는 어떤 일이 병렬적으로 일어난다고 생각하면 된다. 내가 어떤 일을 하는 동안 다른 쪽에서 일을 하고 있다면, 난 다른 곳에서 일을 하고 끝나면 다시 돌아오면 된다.

  이 비유가 좋지 않은 비유라고 느껴진다면.. 동기의 경우, 어떤 일 A와 B가 있을 때, 이 A와 B는 종속되어 있다. 따라서 A와 B가 작업을 한다고 하면, A가 먼저 작업을 끝내야 B가 작업을 할 수 있다.

  비동기의 경우, 이 A와 B는 독립적이다. 누가 일을 하든 말든 나는 내 위치에서 내 일을 하면된다.

- **왜 자바스크립트에서 이렇게 비동기처리를 강조하는지?**

  유독 다른 프로그래밍언어와 달리 자바스크립트에서 특히 비동기를 강조한다는 느낌이 든다. 나는 이 이유가 **자바스크립트의 태생은 웹을 위한 언어** 였기 때문이라고 생각한다.

  웹의 목표는 사용자에게 화면을 보여주는 것이 1순위이다. 웹에서 가장 최악의 행위 중 하나는사용자에게 화면이 보이지 않는 것이다. 하지만 웹의 동작은 서버와 함께하고, 그 외 다양한 이벤트와 함께 하므로, 웹에서는 이런 '대기하는 행위'가 필요할 수 밖에 없다. 이 '대기하는 행위'에 대해서 생각해보자. HTTP 메소드를 위한 통신, 이벤트 핸들링(이벤트가 올때까지 기다리고, 이벤트가 와야 실행하니깐), 타이머.. 웹에서는 아주 빈번하게 발생한다. 하지만 이렇게 대기하는 동안 진짜로 대기하고 있으면 어떻게 될까? 사용자에게 화면을 보여주지 않고 사용자를 대기하게 한다면?

  그렇지만, 자바스크립트는 싱글 스레드 언어이다. 싱글 스레드 언어기 때문에 언어 수준에서는 이를 처리할 수가 없기 때문에 따로 비동기 처리를 도입하게 되었다.

- **그래서 정리하면**

  무언가에 대해서 대기하는 동작에 대해서 비동기 처리를 사용하게 된다. 그리고 이렇게 대기하는 중에는 다른 작업을 한다. 이 '다른 작업'은 코드 내에 비동기가 아닌 코드를 실행하는 작업을 뜻한다.

#### 콜백함수

자바스크립트에서는 함수 역시 객체이므로, 다른 함수에 인자에 들어갈 수 있는데 이 인자에 들어갈 수 있는 함수를 콜백함수라고 한다. 그런데 왜, 비동기 작업에서 콜백함수가 나온 걸까?

- **비동기 작업은 함수로 일어난다.**

  이게 무슨 소리냐면... 비동기를 위한 함수들을 브라우저가 제공하게 되고, 우리는 그 함수에다가 어떤 단위의 동작을 비동기적으로 할지 지정한다.

  예를 들어서 setTimeout을 생각해보자. setTimeout은 타이머 함수로, **일정시간이 지난 후에 어떤 단위의 일을 실행한다.** 이 '어떤 단위'를 우리는 함수라고 정의할 수 있다.

  다른 비동기 함수도 마찬가지이다. 우리는 비동기작업으로 어떤 단위의 일을 실행할지 결정해야하고, 이 때 콜백함수를 사용하게 된다.

  이 때, 콜백함수의 특징을 생각해볼 수 있다. 비동기작업의 본질은 ' **일정시간 기다린 후에**', '특정 작업을 실행한다' 라고 생각할 수 있다. 그리고 이 특정 작업의 형태가 콜백 함수이다. 그렇다면, 콜백 함수를 사용한다는 것은 작업의 순서를 정해준다는 뜻이 함의되어있다고 생각해도 된다.

- **그런데 콜백이 왜 중첩되고, 지옥이 만들어지는가**

  콜백이 중첩되는 상황을 생각해보자. 콜백 함수를 사용한다는 것은 작업의 순서를 정해주는 일이라고 위에서 이야기 했다. 이러한 작업의 순서가 많아 진다면, 이 순서를 위해 계속 콜백함수를 사용하게 될 것이고, 이렇게 콜백이 중첩되게 된다.

  서버에서 데이터를 받아오는 비동기 함수인 request라는 함수가 있다고 하자. 내가 하고 싶은 일은 A라는 서버에서 데이터를 받아오고, 그 데이터를 이용해서 B라는 서버에서 받아오고, 그 데이터를 이용해서 C라는 서버에서 받아오는 이 과정을 pseudo 코드로 작성하면 다음과 같다. 이렇게 되면 벌써부터 가독성이 좋지 않아 지는 것을 확인할 수 있다.

```javascript
request(URL_A, request(URL_B, request(URL_C))
```

### Promise

앞에서 말했듯이 비동기 작업, 특히 일련의 순서를 가지는 비동기 작업을 콜백함수로 처리하게 되면, 가독성이 아주 좋지 않아진다. 함수 안에 함수를 넣는것만 해도 가독성이 좋지 않는데, 실행흐름도 콜백함수는 혼자 이상하게 놀고 있다..

이러한 작업을 조금 더 명확하게 하기 위해서 promise를 도입하게 되었다.

- **Promise가 뭘까?**

  ' **어떤 비동기 작업의 단위**'를 Promise라는 개념으로 만들었다. 따라서 기존의 콜백으로 억지로 비동기를 끼워서 처리했던 것과 다르게, Promise라는 단위하나로 묶어서 비동기를 처리할 수 있게 되었다.

- **어떻게 실행되는가?**

  **1\. 어떤 비동기 작업단위를 Promise 객체로 만든다.**

  비동기 작업단위를 묶어서 Promise 객체로 만드는 그 순간, 비동기 작업이 시작된다고 생각하면 된다.

  **2\. 그 비동기 작업단위 다음의 작업을 then 을 통해서 지정한다.**

  이렇게 하면, 비동기 작업이 끝나면 알아서 then을 통해서 실행된다. 또한 이때 then을 통해서 받아오는 데이터는 resolve를 통해 리턴된 데이터 이다.

- **형태**

  Promise의 형태는 Promise((resolve, reject))의 형태이다. resolve는 비동기 처리가 정상적으로 완료된 시점에 호출되는 함수, reject는 promise 내에서 문제가 생긴 경우이다. resolve의 인자로는 then으로 넘겨줄 리턴 값을 넣는다.

- **관련 내장 함수**

  \- Promise.all(iterable) : promise 객체 여러개를 배열로 받은 후, 그 안에 있는 promise를 모두 실행 한 후, then을 호출한다. 배열 안에 있는 비동기 작업(promise)를 병렬로 처리하기 위해서 사용한다.

  \- Promise.race(iterable)  : promise 객체 여러개를 배열로 받은 후, 여기서 제일 먼저 끝낸 resolve 만 받아서 then을 실행한다.

정리하자면, 콜백에 콜백을 중첩시켜서 작업의 순서를 정해주는 것과 달리, then을 통해서 작업의 순서를 정해주게 되었으므로 콜백을 사용하면 n-depth를 이용할 일을 1 depth로 끝낼 수 있게 되었다.

#### async/await

promise를 조금 더 편하게 사용하기 위한 syntax sugar로 async/await가 도입되었다. promise는 콜백함수의 depth를 1단계로 줄여주긴 하지만, promise의 경우 실행방식이 일반적인 코드의 흐름과는 다르게 promise가 있으면 그게 실행되고 다음 코드가 실행되다가 promise가 끝나면 then으로 다음 코드가 실행되는 순으로 일반적인 코드 흐름과 다르다는 불편한 점이 있었다.

일반적인 코드흐름은 동기적인 흐름으로 발생한다. async/await를 통하여 이루고자 하는 일은 비동기적인 코드를 동기적 흐름 처럼 보이게 하는 것이다.

#### fetch

fetch는 기존의 XMLHTTPRequest를 대신하여 비동기 http 요청을 더 편하게 사용하도록 만들어진 api이다. 역시 서버에서 데이터를 받아오는 과정이므로 비동기 작업이고, 따라서 위의 promise를 통해 사용할 수 있다.

fetch 를 통해 받아온 데이터는 response 객체이므로, 이 객체를 따로 변환해주는 작업이 필요하다. 이는 .json이나 .text를 사용한다.

### 회고

**잡담**

- TIL을 안쓰니깐 머릿속에서 정리가 잘 안되는 것 같아서 머릿속에서 한 번 더 정리할 겸, 아주 오랜만이지만 그리고 날짜도 애매하지만 fetch까지 배웠던 내용에 대해서 작성한다. 그 뒤의 내용은 따로 작성하도록 하겠다.

  이해하느라 제일 애먹었던 내용이여서 적으면서도 어떻게 적어야하나 싶었다ㅋㅋ 역시 내 말로 설명하는건 정말 어렵지만... 그래도 TIL을 쓴 날과 안 쓴 날의 이해의 질이 다른 것 같아서 이제 다시 열심히 쓸 것 같다. 물론 당분간은 ~4.1n이라서 시간을 여행하고 있겠지만... 그래도 오늘부터 TIL 쓸 시간에 알람도 맞춰놓았다ㅋㅋㅋㅋㅋ 홧팅..

- 비동기라는 개념이 너무 이해가 안되서 고생을 엄청 했었다. 지금도 제대로 이해한게 맞는지는 모르겠다.. 도대체가 이것만 며칠째 이해하고 있는지 모르겠네..
- Promise와 async/awai에 대해서는... 나중에 article을 올리려고 한다. 이렇게 말한 article 주제가 벌써 5개가 넘어가는 것 같지만.. 우선 노션 클론 끝나면...
