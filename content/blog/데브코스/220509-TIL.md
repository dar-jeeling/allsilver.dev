---
title: '220509 TIL'
date: 2022-05-10 03:51:00
tags: ['TiL']
category: '데브코스'
draft: false
---

**주의!** 🍓 이모티콘이 붙어있으면 작성자의 주관적 내용

## Today I Learned

더보기

### 1\. Vue 시작하기 : 공식문서의 흐름을 이해하고 실습해보았다.

#### 1-1. Vue ?

Vue는 FrameWork로 화면에 출력할 레이아웃을 관리하는 역할을 한다(핵심적으로 뷰view 레이어에 초점을 맞춘다). Vue는 따라서 다른 라이브러리와 통합 하기 쉽다.

🍓 레이아웃만 관리하는 프레임워크이므로, 레이아웃이 아니면 다른 쪽이랑 커플링 효과가 발생하지 않는다.

#### 1-2. 선언적 렌더링

**선언적 렌더링**: 뷰 애플리케이션에서 사용하는 데이터(반응형 데이터)를 HTML 안에서 템플릿 문법 ( {{ }} ) 에서 선언적으로 렌더링 할 수 있다.

🍓결국에는 뷰 애플리케이션과 HTML의 DOM 요소가 연결되어있다는 것이고, 뷰의 라이프사이클은 뷰 애플리케이션을 생성하고, HTML과 연결되며, 연결이 끊길 때까지 (그 사이에 데이터가 update 되거나 할 수 있다)의 일련의 과정을 말한다.

#### 🍓**하나의 Vue 애플리케이션을 작성하는 큰 흐름은 다음과 같다.**

1\. (cdn을 사용할 경우)**Vue.createApp(App) 메소드를 통하여 뷰 애플리케이션을 만든다.**인자로 들어가는 객체는 컴포넌트 객체이며,**객체 안에 data와 method를 정의한다. (정의된 내용을 옵션이라고 한다.)** 여기서 data를 정의하면, 이 데이터는 반응성을 가진다.

2\. 이 뷰 애플리케이션을 mount 함수를 이용하여 뷰 인스턴스로 만든다. 이 말은**애플리케이션을 mount 시킨다는 말인데, 뷰 애플리케이션과 HTML 요소를 연결한다는 뜻이다.**(이 인스턴스는 프록시 객체로 구현되어있다. 그렇기 때문에 안쪽의 data를 반응형으로 구현할 수 있고, 이 data는 앞에서 말했듯이 HTML 요소와 연결되어 있다.)

#### 1-3. 디렉티브 속성 (v-)

**\- v-** 가 붙은 속성은 _디렉티브_ 라고 하고, 뷰에서 사용할 수 있는 특별한 속성이다. 대표적으로 v-bind를 통하여 속성에 뷰 애플리케이션의 data를 바인딩할 수 있으며, v-on을 통하여 이벤트핸들링을 할 수 있다. ( **v-on: 이벤트="메소드이름"** 의 형태로 사용된다)

\- 그 외에도 v-if, v-for과 같은 다양한 디렉티브들이 있다.

🍓 이러한 디렉티브는 자바스크립트의 일부 기능을 HTML 에서 사용하기 위함으로 보인다. 개인적으로, 이러한 디렉티브를 통해서 js 코드와 html 코드가 더 유연하게 연결될 수 있는 것처럼 보이는 것 같다.

#### 1-4. 컴포넌트

\- App 컴포넌트 안을 구성하는 컴포넌트를 정의할 수 있다. (이 앱도 컴포넌트이다) 컴포넌트 객체는 template과 props 속성으로 구성되어 있으며, template에는 HTML 형태, props에는 데이터가 들어간다.

\- 그리고 만들어진 컴포넌트를 상위 컴포넌트(App)에 components 속성으로 등록한다. 이 App 이라는 객체는 결국 HTML 요소와 마운팅되는 요소이다. 따라서, App 의 components 역시 HTML으로 넘어가게 되는 것이고, 통상적으로 Camel Case로 작성된 컴포넌트 이름은 dash case로 바꾸어져서 사용이된다. (구체적으로 예시를 들어보면 App의 하위 컴포넌트로 SidebarHeader 라는 컴포넌트가 들어갔다고 하면, 이는 html에서 sidebar-header 와 같은 이름으로 사용하게 된다.)

-하위 컴포넌트의 props 는 html의 속성값처럼 처리한다. 위에서 언급한것처럼 하위 컴포넌트의 props를 Camel case로 작성했다면, dash case로 바꾸어서 html의 속성값이 되고, 값을 넣어주면 된다.

\- 속성 값을 넣어줄 때, 마찬가지로 디렉티브 속성을 사용할 수 있다.

🍓 결국에는 최상위 컴포넌트를 뷰 인스턴스로 만들고, 하위 컴포넌트는 최상위 컴포넌트의 components 속성에 넣어서 취급하겠다는 이야기이다.

### 2\. 애플리케이션과 인스턴스 생성

#### 2-1. 애플리케이션과 인스턴스 객체

\- 뷰 애플리케이션을 생성하기 위해서는 애플리케이션과 인스턴스 객체의 개념이 있다.

🍓 위에서 언급하였듯이 뷰 라이프 사이클의 가장 큰 그림은 **컴포넌트를 만들고, 그 컴포넌트를 뷰 애플리케이션으로 만들고 나서, DOM 요소에 마운팅 시키는 것** 이라는 생각이 든다. 따라서, 컴포넌트 객체를 createApp을 통해서 뷰 애플리케이션화 하고, 이를 인스턴스 객체로 만든다(인스턴스 객체로 만들기 위하여 뷰 애플리케이션의 mount 메서드를 사용해야 한다). 그리고 **데이터의 반응성을 위하여, 이 인스턴스 객체를 Proxy 객체로 구현** 하여 내부에서 일어나는 변화를 감지하고 그에 맞게 update 한다.

### 3\. 라이프 사이클

\- 뷰 애플리케이션을 만들고, mount 메서드를 사용한다고 가정한다. 라이프사이클 훅은 다음과 같다.

1\. beforeCreate : 뷰 애플리케이션이 만들어지기 직전을 의미한다.

2\. **created** : **뷰 애플리케이션이 생성된 직후를 의미한다. 🍓 즉, 여기서부터 뷰 애플리케이션의 데이터를 다룰 수 있다.**

3\. beforeMount : 준비된 내용을 DOM 과 연결(렌더링) 하기 직전이다.

4\. **mounted** : **뷰 애플리케이션과 DOM 이 연결된 직후를 의미한다. 따라서 DOM API를 다룰 수 있다.**

5\. beforeUpdate : 데이터가 수정이 되고 나서, 화면이 업데이트되기 전의 상태이다.

6\. updated : 데이터가 수정이 되고 나서, 화면이 업데이트된 직후의 상태이다.

7\. beforeUnmount : unmount 메소드를 통해서 연결이 해제되기 직전의 상태이다.

8\. unmount: unmount 메소드를 통해서 연결이 해제된 직후의 상태이다.

### 4\. 템플릿 문법

### 5\. Data와 Methods

#### 5-1. 데이터

**🍓 컴포넌트는 당연히 재사용이 가능해야하고, 각자 독립된 상태를 가져야한다. 따라서 같은 컴포넌트를 여러개 만든다고 해도 이 둘은 각기 다른 상태를 가지게 되고, 우리는 프로그래밍을 하면서 이 상태, 데이터에 대한 불변성을 보장해야한다.**

\- 따라서, 컴포넌트를 정의할 때 data 옵션은 함수로 만들고 그 안에서 return 키워드로 반환해야한다.

\- 컴포넌트에서 data 옵션을 통해서 만들어진 데이터들은 뷰 인스턴스 객체에서 바로 (this.data) data 속성으로 접근할 수도 있고, 뷰 인스턴스 객체의 내장객체인 \$data에서 접근할 수도 있다.

\- 기본적으로는 컴포넌트에 data 옵션에 선언한 반응형 데이터들은 기본적으로는 \$data에 선언이 된다. 하지만 인스턴스가 만들어질때 this를 통해서 해당하는 데이터에 접근할 수 있도록 이 데이터와 인스턴스가 바인딩 된다 **.**

\- 따라서 반응성을 가진 데이터를 접근할 때는, 명시적으로 반응형 데이터라는걸 보이기 위해 \$data를 통해 접근하는 것을 권장한다.

**🍓이 말을 다시 말하면 \$data에 바인딩되는 값 만이 반응형 데이터라는 뜻이다.**

#### 5-2. Proxy

\- 뷰 에서 반응형 레이아웃은 Proxy 객체를 통해서 구현된다. 이는 Proxy 객체의 기본적인 기능을 생각해보면 연결짓기 쉽다. Proxy(감시할 target, handler)를 통해서 target을 감시하며 (즉 데이터가 바뀜을 감지하여), 핸들링을 해줄 수 있다.

#### 5-3. 메소드

\- 컴포넌트의 인스턴스를 항상 참조할 수 있어야 한다. (당연히, 데이터를 계속 참조하고 메소드가 실행되어야하기 때문에) 이 때, 주의할점은 메서드는 화살표함수를 사용해서는 안된다는 점이다. 이유는 this에 대한 정의 때문인데, 화살표 함수를 사용하는 경우에는 적절한 this의 값을 바인딩하지 못한다.

**🍓 내가 알기로는 화살표 함수는 함수 자체에서 this 바인딩을 가지지 못한다. 따라서 화살표 함수 내부에서 this를 참조하게 되면 화살표 함수가 정의된 위치에 의해서 결정된다. 이 말은 화살표 함수 내부에서 this 를 참조하면 상위 스코프의 this를 가지기 때문에, 만들어진 인스턴스 객체가 아니라 저 멀리(뭐라 표현해야할지 모르겠다) 가버린다는 것이다.**

**🍓 뷰 인스턴스가 만들어지는 일련의 과정이 생성자 함수를 통해서 객체를 만들어내는 과정과 비슷하다고 느껴졌다. 처음에 생성한 컴포넌트의 옵션을 활용해서 data와 method를 정의하고, 이 data의 경우 만들어진 인스턴스 객체의 속성에 바인딩하고(정확하게는 내장객체 \$data에 바인딩 된 이후겠지만), method를 바인딩하는데 method를 정상적으로 동작시키기 위해서 이 method는 뷰 인스턴스 객체에 대한 data를 참조해야하고 이를 위해서 화살표함수로 만들지 않는다.**

## 오늘 하루에 대해서

- 오늘 Vue 에 대한 강의를 듣고, 내용을 처음부터 복기하면서 작성해보고자 TIL 형식을 조금 바꿨는데.... 별론거같다. 내 생에 TIL을 이렇게 오랫동안 쓴적은 처음이다ㅠㅠ ㅋㅋㅋㅋ..... 뭐든지 정답은 없겠지만... 데브코스 동안 여러가지 형식을 시도해보겠다. 그래도 덕분에 색다르게 TIL을 적을 수 있었다.
- 학습법에 대한 특강을 듣고나서.... 나의 최적화된 학습법이 무엇일까라는 생각을 하게 된다. 최근에 많이 든 생각인데 나는 강의를 쭉-듣는 스케줄에 진짜진짜 취약하다.ㅋㅋㅋㅋ 오늘도 원래는 코어타임 내에 오늘 강의를 듣고, 이후에 스터디에 대한 공부를 하려고 했었는데.... 스터디 손도 못댔다..... (오늘 지식나눔 세션이 있던걸 감안하더라도)사실 비대면 수업을 들으면서 어렴풋이 느꼈던 지점이긴 하지만.... 그래서 학습법을 조금 바꿔서, 내일 부터는 뽀모도로를 도입해서 강의를 듣는 시간과 내가 뭔가 다른걸 하는 시간을 구분하고 번갈아서 학습해보려고 한다. 이러다가 두 마리 토끼 다 못잡고 둘 다 애매한 상태로 하루를 보내는게 아닌가... 싶긴 하지만... TIL이든 학습법이든지 간에 여러가지 시도해보고 나에게 맞는 방법을 좁혀나가는게 우선인 것 같다.
